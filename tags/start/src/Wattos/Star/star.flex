/*
 * This software is copyright (c) 2006 Board of Regents, University of
 * Wisconsin. All Rights Reserved.
 *
 * FILE:        $Source$
 *
 * AUTHOR:      $Author$
 * DATE:        $Date$
 *
 * UPDATE HISTORY:
 * ---------------
 * $Log$
 * Revision 1.1  2007/06/19 18:07:54  jurgenfd
 * Initial revision
 *
 * Revision 1.3  2006/09/20 16:32:58  jurgen
 * Updated STAR flex lexer and parser to Dimitri's specs for faster parsing of ;; delimited values etc.
 * Changed bug reports to Trac system outside of the Wattos package but nicer.
 * */
//***************************************************************************
// Scanner flex specification
//***************************************************************************
/* Lex Definitions for a STAR File */

package Wattos.Star;
import Wattos.Utils.*;

/**
 * STAR Lexer with some error checking.
 *
 * <STRONG>NOTES</STRONG>:<UL>
 *  <LI>this scanner does not close input file on EOF</LI>
 *  <LI>the scanner does not generate fake "end-of" tokens for
 *      end of data block, end of global block, end of loop
 *      (if closing "stop_" is omitted)</LI>
 *  <LI>this scanner generates "keyword in value" warnings (in C++
 *      version they are generated by the parser)</LI>
 * </UL>
 */

%%

%class STARLexer
%public
%line
%column
%unicode
//%type Types
%int
%x YYSINGLE YYDOUBLE YYSEMI YYSEMIEND

%init{
    buf = new StringBuilder();
%init}

%{
    public static final int ERROR = 0;
            /** Parser warning. */
    public static final int WARNING = 1;
            /** Start of global block. */
    public static final int GLOBALSTART = 2;
            /** End of global block. */
    public static final int GLOBALEND = 3;
            /** Start of data block. */
    public static final int DATASTART = 4;
            /** End of data block. */
    public static final int DATAEND = 5;
            /** Start of saveframe. */
    public static final int SAVESTART = 6;
            /** End of saveframe. */
    public static final int SAVEEND = 7;
            /** Start of loop. */
    public static final int LOOPSTART = 8;
            /** End of loop. */
    public static final int STOP = 9;   
            /** Tag. */
    public static final int TAGNAME = 10;
            /** Value enclosed in single quotes. */
    public static final int DVNSINGLE = 11;
            /** Value enclosed in double quotes. */
    public static final int DVNDOUBLE = 12;
            /** Value enclosed in semicolons. */
    public static final int DVNSEMICOLON = 13;
            /** Framecode value. */
    public static final int DVNFRAMECODE = 14;
            /** Bareword value. */
    public static final int DVNNON = 15;
            /** Comment. */
    public static final int COMMENT = 16;
            /** End of input. */
    public static final int EOF = 17;


    /** token names. Use int token constant as array index */
    public static final String [] TOKEN_TYPES = {
    "ERROR",
    "WARNING",
    "GLOBALSTART",
    "GLOBALEND",
    "DATASTART",
    "DATAEND",
    "SAVESTART",
    "SAVEEND",
    "LOOPSTART",
    "STOP",
    "TAGNAME",
    "DVNSINGLE",
    "DVNDOUBLE",
    "DVNSEMICOLON",
    "DVNFRAMECODE",
    "DVNNON",
    "COMMENT",
    "EOF"
};

    /* buffer for quoted values */
    private StringBuilder buf;
    /** Returns line number (counting from 1).
     * Returns <CODE>yyline + 1</CODE>
     * @return line number
     */
    public int getLine() {
        return yyline + 1;
    }
    /** Returns column number.
     * @return column number
     */
    public int getColumn() {
        return yycolumn;
    }
    /** Returns text of the last token.
     * <P>
     * Use this method instead of <CODE>yytext()</CODE> to retrieve tokens.
     *<P>
     * Because quoted values (DVNSINGLE, DVNDOUBLE, DVNSEMICOLON) are parsed
     * differently from non-quoted ones (DVNNON and DVNFRAMECODE), their
     * text is stored in a separate buffer.
     * <P>
     * For other token types returns <CODE>yytext()</CODE>.
     */
    public String getText() {
        if( buf.length() < 1 ) return yytext();
	return buf.toString();
    }
    /** Pushes number of characters back into input stream.
     * @param num number of characters to push back
     */
    public void pushBack( int num ) {
        yypushback( num );
    }
//******************************************************************************
%}

WS=[ \t\b\012]
NON_WS=[^ \t\b\012]
NL=[\n]
WS_NL = ({WS}|{NL})

GLOBALSTART         = ([gG][lL][oO][bB][aA][lL]_)
DATASTART           = ([dD][aA][tT][aA]_)
SAVEEND             = ([sS][aA][vV][eE]_)
LOOPSTART           = ([lL][oO][oO][pP]_)
STOP                = ([sS][tT][oO][pP]_)
/*
   NMR-STAR 3.0/PDBX tagname
   TAGNAME              _[_[:alnum:]]+\.[][_[:alnum:]%-]+
*/
/* NMR-STAR 2.1 tagname */
/* TAGNAME             = (_[_[:letter:][:digit:]+[\]\[_[:letter:][:digit:]%-]+) */
TAGNAME             = (_[_[:letter:][:digit:]]+[._\[\][:letter:][:digit:]%-]+)
SINGLESTART         = {WS}+\'
 /* SINGLEEND           = \'{WS}+ */
DOUBLESTART         = {WS}+\"
/* DOUBLEEND           = \"{WS}+ */

/*
   PDBX definition for code (sf name) is
   [_,.;:"&<>()/\{}'`~!@#$%A-Za-z0-9*|+-]+
*/
FRAMECODE           = \$[_,.;:\"&<>()/\{}'`~!@#$%A-Za-z0-9*|+-]+
COMMENT             = #

%%
<YYINITIAL> {
    <<EOF>> {
        buf.setLength( 0 );
        return EOF;
    }
    {GLOBALSTART}{WS}* {
        buf.setLength( 0 );
	    return GLOBALSTART;
    }
    {DATASTART}{NON_WS}+ {
        buf.setLength( 0 );
	    buf.append( yytext().substring( 5 ) );
	    return DATASTART;
    }
    {SAVEEND}{NON_WS}+ {
        buf.setLength( 0 );
	    buf.append( yytext().substring( 5 ) );
	    return SAVESTART;
    }
    {SAVEEND}{WS}* {
        buf.setLength( 0 );
	    return SAVEEND;
    }
    {LOOPSTART}{WS}* {
        buf.setLength( 0 );
	    return LOOPSTART;
    }
    {STOP}{WS}* {
        buf.setLength( 0 );
	    return STOP;
    }
    {COMMENT}.* {
        buf.setLength( 0 );
	    return COMMENT;
    }
    {TAGNAME} {
        buf.setLength( 0 );
	    buf.append( yytext() );
	    return TAGNAME;
    }
    {FRAMECODE} {
        buf.setLength( 0 );
	    buf.append( yytext().substring( 1 ) );
	    return DVNFRAMECODE;
    }
    {SINGLESTART} {
//System.err.printf( "Matched %s in {SINGLESTART}\n", yytext() );
        buf.setLength( 0 );
	    yybegin( YYSINGLE );
    }
    {DOUBLESTART} {
        buf.setLength( 0 );
        yybegin( YYDOUBLE );
    }
/*
    ^;{WS_NL} {
//    General.showDebug( "Matched %s in ^{SEMI}" + yytext() );
        buf.setLength( 0 );
        yybegin( YYSEMI );
    }
*/
    ^;.* {
//    General.showDebug( "Matched %s in ^{SEMI}" + yytext() );
        buf.setLength( 0 );
        buf.append( yytext().substring( 1 ) );
        yybegin( YYSEMI );
    }
    {NON_WS}+ {
//    General.showDebug( "Matched in {NON_WS}+ " + yytext());
        buf.setLength( 0 );
	    buf.append( yytext() );
	    return DVNNON;
    }
    {WS_NL}+ {}
}

<YYSINGLE, YYDOUBLE> {
    . {
//System.err.printf( "Matched %s in {YYSINGLE|DOUBLE}, cont.\n", yytext() );
        buf.append( yytext() );
    }
}

<YYSINGLE>'/{WS_NL}+ {
//System.err.printf( "Matched %s in {YYSINGLE}, exit\n", yytext() );
    yybegin( YYINITIAL );
    return DVNSINGLE;
}

<YYDOUBLE>\"/{WS_NL}+ {
    yybegin( YYINITIAL );
    return DVNDOUBLE;
}

<YYSEMI> {
    {NL} {
//System.err.printf( "In YYSEMI, matched |%s|, begin SEMIEND\n", yytext() );
	yybegin( YYSEMIEND );
    }
    .+ {
//System.err.printf( "In YYSEMI, matched |%s|\n", yytext() );
        buf.append( yytext() );
    }
}

<YYSEMIEND> {
    ;{WS_NL}+ {
//System.err.printf( "In YYSEMIEND, matched |%s|, exit\n", yytext() );
        yybegin( YYINITIAL );
        return DVNSEMICOLON;
    }
    {NL} {
        buf.append( "\n" );
    }
    [^;] {
//System.err.printf( "In YYSEMIEND, matched |%s|, drop back\n", yytext() );
        buf.append( "\n" );
	    buf.append( yytext() );
	    yybegin( YYSEMI );
    }
}

<YYINITIAL,YYSINGLE,YYDOUBLE,YYSEMI,YYSEMIEND>.|\n {
//System.err.printf( "In ERROR, matched |%s|\n", yytext() );
    buf.setLength( 0 );
    buf.append( "Unknown token: ``" );
    buf.append( yytext() );
    buf.append( "''" );
    return ERROR;
}
