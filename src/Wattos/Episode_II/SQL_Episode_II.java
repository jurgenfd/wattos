/*
 * SQL_Episode_II.java
 *
 * Created on December 5, 2001, 1:51 PM
 *
 *This software is copyright (c) 2002 Board of Regents, University of Wisconsin.
 *All Rights Reserved. No warranty implied or expressed.
 */
package Wattos.Episode_II;

import java.io.*;
import java.sql.*;
import java.util.*;
import java.util.zip.*;
import cern.colt.list.*;
// Wattos utils
import Wattos.Utils.*;
// Wattos utils
import Wattos.Database.*;

/** The access methods needed for most db entities.
 * The oracle packages imported (<CODE>oracle.sql.*</CODE>,
 * <CODE>oracle.jdbc.driver.*</CODE>) are needed for dealing with the BLOB and CLOB
 * objects. They can be taken out now that LOBS are used anymore.
 *
 *The business logic that applies for the refereces mrblock contents: dbfsfile objects is
 *the following:
 *- Files don't necessarily get created, modified, deleted in sync with the database
 *methods encoded here. 
 *<UL>
 *<LI>Normally files aren't modified after creation but just in case
 *they do and for catching i/o errors a md5 filesum will be stored in the database to
 *make sure the data integrity is there.
 *<LI>Deletions are optimized by doing 1 SQL query that finds all existing dbfs file ids and
 *checking for any that are no longer referred to and those that are missing. The last category would be
 *a BIG problem. For all entries that have missing data the entry should be recreated, probably
 *completely.
 *</UL>
 */
public class SQL_Episode_II extends SQL_Generic{    

    /** The exact string used in the relational database for the file detail*/
    public static final String FILE_DETAIL_CLASSIFIED = "1-original";
    public static final String FILE_DETAIL_PARSED     = "2-parsed";
    public static final String FILE_DETAIL_CONVERTED  = "3-converted-DOCR";
    public static final String FILE_DETAIL_FILTERED   = "4-filtered-FRED";

    public static final String BLOCK_DETAIL_RAW         = FILE_DETAIL_CLASSIFIED;
    public static final String BLOCK_DETAIL_PARSED      = FILE_DETAIL_PARSED;
    public static final String BLOCK_DETAIL_CONVERTED   = FILE_DETAIL_CONVERTED;
    public static final String BLOCK_DETAIL_FILTERED    = FILE_DETAIL_FILTERED;
    
    /** Series of table/column tuples that contain references to a dbfs file 
     */
    public static final String[][] DBFS_REFERING_TUPLES = { { "mrblock", "dbfs_id" } };
    
    /** Just calling super class
     * @param properties User name, password, etc.
     */
    public SQL_Episode_II( Properties properties ) {
        super(properties);
    }


    /** Just calling super class
     */
    public SQL_Episode_II( Globals g ) {
        super(g);
    }

    
    /** Get all unique file details from DB. Return null for an error and an
     *empty list if none exist.
     */
    public ArrayList getMRFileDetailOptions() {

        // The return list
        ArrayList ids = new ArrayList();
            
        String mrblock_table = SQL_table_prefix + "mrblock"; 
        String mrfile_table  = SQL_table_prefix + "mrfile"; 
        
        try 
        {
            String q = "SELECT DISTINCT DETAIL\nFROM " + mrfile_table;
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery(q);                
            while (rs.next()) 
            {
                ids.add( rs.getString("DETAIL") );
            }
            
            if (ids.size()==0){
                General.showWarning("no result querying for: "+
                    "SELECT DISTINCT TEXT_TYPE FROM " + mrblock_table);
            }                                               
            // Do these need to be executed before a return, or is it just 
            // nice to do so?
            rs.close(); 
            stmt.close();     // All done with that result set
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.getMRFileDetailOptions found Database access failed\n" + e);
            // Value might have been changed so we use the real thing
            // in order to signal error upon return.
            return (null);
        }
        return(ids);
    }

    
    /** Get all unique block text types from DB. Return null for an error and an
     *empty list if none exist.
     */
    public ArrayList getMRBlockTextTypes() {

        // The return list
        ArrayList ids = new ArrayList();
        String mrblock_table = SQL_table_prefix + "mrblock"; 
            
        try 
        {
            String q =  "SELECT DISTINCT TEXT_TYPE\n" +
                        "FROM " + mrblock_table;
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery(q);                
            while (rs.next()) 
            {
                ids.add( rs.getString("TEXT_TYPE") ); 
            }
            
            if (ids.size()==0){
                General.showWarning("no result querying for: "+
                    "SELECT DISTINCT TEXT_TYPE \n" +
                    "FROM " + mrblock_table + " b, \n"
                    );
            }                                               
            // Do these need to be executed before a return, or is it just 
            // nice to do so?
            rs.close(); 
            stmt.close();     // All done with that result set
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.getMRBlockTextTypes found Database access failed\n" + e);
            // Value might have been changed so we use the real thing
            // in order to signal error upon return.
            return (null);
        }
        return(ids);
    }

    
    /** Get the mrfile_id given the pdb_id and detail.
     * The method does NOT use transaction management (only queries).
     * @return The mrfile_id array.
     * @param pdb_id
     * @param detail  */
    public ArrayList getMRFileIdsByPDBIdByDetail(String pdb_id, String detail) {

        // The return list
        ArrayList ids = new ArrayList();

        if ( ( pdb_id != null ) && (! Wattos.Utils.Strings.is_pdb_code(pdb_id))) {
            General.showError("in SQL_Episode_II.getMRFileIdsByPDBIdDetail found given pdb_id doesn't look like a pdb_id:["+
                pdb_id.toString()+"]");
            return ( null );
        }
        String mrfile_table = SQL_table_prefix + "mrfile"; 
            
        try 
        {
            StringBuffer sb = new StringBuffer( "SELECT mrfile_id FROM " + mrfile_table + General.eol );
            if ( pdb_id != null && detail != null )
                sb.append("WHERE ");            
            if ( pdb_id != null )
                sb.append("pdb_id='"+pdb_id+"' ");
            if ( detail != null ) {
                if ( pdb_id != null )
                    sb.append("AND ");
                sb.append("detail='"+detail+"' ");                
            }
            String q = sb.toString();
            //General.showOutput("Using query:["+q+"]");
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery(q);                
            while (rs.next()) 
            {
                ids.add( new Integer( rs.getInt("mrfile_id") ) );
            }
            
            // Do these need to be executed before a return, or is it just 
            // nice to do so?
            rs.close(); 
            stmt.close();     // All done with that result set
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.getMRFileIdsByPDBIdDetail found Database access failed\n" + e);
            // Value might have been changed so we use the real thing
            // in order to signal error upon return.
            return (null);
        }
        
        if (ids.size()==0){
            General.showWarning("no result querying for "+
                "mrfile_id with pdb_id: ["+pdb_id+"] and detail:["+
                detail+"]");
        }                                               
        return(ids);
    } 


    /** Null a column for each row.
     */
    public boolean nullColumn( String tableName, String columnName) {
        String q = 
            "UPDATE " + tableName + General.eol+
            "SET " + columnName + " = NULL";                
        try 
        {
            //General.showOutput("Using query:["+q+"]");
            Statement stmt = conn.createStatement();
            stmt.executeUpdate(q);
            // Do these need to be executed before a return, or is it just 
            // nice to do so?
            stmt.close();     // All done with that result set
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e)
        {
            General.showError("in SQL_Generic.nullColumn found Database access failed\n" + e);
            General.showError("Full query is: \n" + q);
            // Value might have been changed so we use the real thing
            // in order to signal error upon return.
            return false;
        }

        return true;
    }
    
    /** Clear all BMRB entry id links for each entry.
     *
    public boolean updateBMRBMatch(String pdb_id, int bmrb_id ) {
        try 
        {
            String q = 
                "UPDATE entry" +General.eol+
                "SET bmrb_id = " + bmrb_id +General.eol+
                "WHERE pdb_id = '" + pdb_id + "'";
            //General.showOutput("Using query:["+q+"]");
            Statement stmt = conn.createStatement();
            int resultCount = stmt.executeUpdate(q);
            if ( resultCount > 0 ) {
                General.showDebug("Updated pdb_id " + pdb_id + " to bmrb id: " + bmrb_id);
            }
            if ( resultCount > 1 ) {
                General.showError("Should have updated at one entry but did more.");
                return false;
            }
            // Do these need to be executed before a return, or is it just 
            // nice to do so?
            stmt.close();     // All done with that result set
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.clearBMRBMatch found Database access failed\n" + e);
            // Value might have been changed so we use the real thing
            // in order to signal error upon return.
            return false;
        }

        return true;
    }
     */
    
    /** Get the pdb ids for mr files with certain details values
     * The method does NOT use transaction management (only queries).
     * @return The mrfile_id array.*/
    public ArrayList getPDBIdFromMRFileByDetail( String detail ) {

        // The return list
        ArrayList ids = new ArrayList();
            
        String mrfile_table = SQL_table_prefix + "mrfile"; 

        try 
        {
            String q = 
                "SELECT pdb_id FROM " + mrfile_table + General.eol+
                "WHERE detail='" + detail + "'\n" +
                "ORDER BY pdb_id";                
            //General.showOutput("Using query:["+q+"]");
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery(q);      
            int count = 0;
            while (rs.next()) 
            {
                String tmp = rs.getString("pdb_id");
                count++;
                ids.add( tmp );
            }
//            General.showOutput("In getPDBIdFromMRFileByDetail found number rs: " + count);
//            General.showOutput("In getPDBIdFromMRFileByDetail found size results: " + ids.size());
            
            // Do these need to be executed before a return, or is it just 
            // nice to do so?
            rs.close(); 
            stmt.close();     // All done with that result set
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.getMRFileIdsByPDBIdDetail found Database access failed\n" + e);
            // Value might have been changed so we use the real thing
            // in order to signal error upon return.
            return (null);
        }
        if (ids.size() == 0) {
            General.showWarning("Found NO mr files in db with detail: " +
                detail);
        }
        
        StringArrayList idsStringArrayList = new StringArrayList(ids);
        StringArrayList duplicates = idsStringArrayList.duplicates();
        if ( duplicates.size() > 0 ) {
	        General.showError("There are duplicates in database: " + duplicates );
	        StringArrayList duplicatesUnique = (StringArrayList) duplicates.clone();
	        duplicatesUnique.make_unique();
	        General.showError("Unique list of them: " + duplicatesUnique);
	        
        }
        return ids;
    }

    /** Get the pdb ids for mr files with certain details values and the time-
     *stamp is older than max days. 
     *Differences between time on the rdbms machine and the
     *executing machine are ignored because the argument is only precise to the
     *day.
     * The method does NOT use transaction management (only queries).
     * @return The mrfile_id array.*/
    public ArrayList getPDBIdFromMRFileByDetailNewerThanDays( String detail,
        int max_days ) {

        // The return list
        ArrayList ids = new ArrayList();

        // Do time manipulations on a calendar
        Calendar cal = Calendar.getInstance();        
        java.util.Date date_current = new java.util.Date(); // Set the date to the current date.
        cal.setTime(date_current);
        // Subtract the number of days from the position on the calendar.
        cal.add(Calendar.DATE, -1 * max_days);
        java.util.Date date_max = cal.getTime();
        String date_iso_escaped = Dates.getDateIsoEscaped( date_max );

        String mrfile_table = SQL_table_prefix + "mrfile"; 
        
        try 
        {
            String q = 
                "SELECT pdb_id FROM " + mrfile_table + General.eol+
                "WHERE detail='" + detail + "' AND\n" +
                "      date_modified > " + date_iso_escaped + General.eol +
                "ORDER BY pdb_id";                
            //General.showDebug("Using query:["+q+"]");
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery(q);                
            while (rs.next()) 
            {
                ids.add( rs.getString("pdb_id") );
            }
            rs.close(); 
            stmt.close();     // All done with that result set
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.getPDBIdFromMRFileByDetailNewerThanDays found Database access failed\n" + e);
            // Value might have been changed so we use the real thing
            // in order to signal error upon return.
            return (null);
        }
        if (ids.size() == 0) {
            General.showWarning("Found NO mr files in db with detail: " +
                detail);
            General.showWarning("and earlier than: " + date_iso_escaped );
        }
        return(ids);
    }

    
    /** Retrieve the total number of parsed entries */
    public int getCountParsedEntries() {
        int result = -1;
        try {
            Statement stmt = conn.createStatement();
            ResultSet rs = null;
            String q =  "select count(distinct pdb_id) from `mrfile`" +
                        "where detail='2-parsed'";
            rs = stmt.executeQuery(q);
            if (rs.next()) {
                result = rs.getInt(1);
            }
            rs.close();
            stmt.close();
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e) {
            General.showError("in SQL_Episode_II.getCountParsedEntries found Database access failed\n" + e);
            return -1;
        }            
        return result;        
    }

    /** Retrieve the total number of parsed constraints */
    public int getCountParsedRestraints() {
        int result = -1;
        try {
            Statement stmt = conn.createStatement();
            ResultSet rs = null;
            String q =  "select sum(item_count) from `mrblock`\n"+
                        "where text_type='2-parsed' AND\n"+
                        "type='entry' and subtype='full'";
            rs = stmt.executeQuery(q);
            if (rs.next()) {
                result = rs.getInt(1);
            }
            rs.close();
            stmt.close();
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e) {
            General.showError("in SQL_Episode_II.getCountParsedRestraints found Database access failed\n" + e);
            return -1;
        }            
        return result;        
    }
    
        
    /** Reserve a new id in the sequence generator table. Get unique sequence id from db.
     * Watch out this will only work up to the number of times that int can handle for
     * int(32) that is: 2 billion (2,147,483,648). Using proprietary Oracle method.
     * @return The next id which is kept in the database and incremented on each call.
     */
    public int getNextSequenceId( String table_name ) {
            
        // Default
        int nextId = Wattos.Utils.General.NULL_FOR_INTS;        
        
        try {
            Statement stmt = conn.createStatement();
            ResultSet rs = null;
            // Method in MySQL
            // function is supposed to return unique id even with multiple users.
            if ( SQL_Generic.DB_VENDOR_USED == SQL_Generic.DB_VENDOR_MYSQL ) {
                int resultCount = stmt.executeUpdate("UPDATE " + table_name + "_id SET id=LAST_INSERT_ID(id+1)");
                if ( resultCount != 1 ) {
                    General.showError("Failed to update counter and therefor could not get a new sequence id for table: " + table_name);
                    return nextId;
                }
                rs = stmt.executeQuery("SELECT LAST_INSERT_ID()");
            } else if ( SQL_Generic.DB_VENDOR_USED == SQL_Generic.DB_VENDOR_ORACLE ) {                
                // Method in Oracle
                // Dual is a guaranteed 1 column, 1 row table that can be used to get
                // exactly one value back. Suggested by Zsolt and SQLPLUS book.
                rs = stmt.executeQuery("SELECT " + table_name + "_id.NEXTVAL FROM DUAL");
            } else {
                General.showError("Set DB vendor isn't a supported ID: " + SQL_Generic.DB_VENDOR_USED);
                return nextId;
            }
            if (rs.next()) {
                nextId = rs.getInt(1);
            }
            rs.close();
            stmt.close();
        // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e) {
            General.showError("in SQL_Episode_II.getNextSequenceId found Database access failed\n" + e);
            // Value might have been changed so we use the real thing
            // in order to signal error upon return.
            return nextId;
        }
        return nextId;
    }
    
    
    
    
    /** Copies rows from 1 set of tables (temporary) to the regular set of tables.
     *It's important to know that this procedure can use transaction management and
     *does not necessarily auto commit by itself. The DBFS files aren't touched by this
     *operation.
     */
    public boolean copyFromSpecialToRegularTables() {
        
        if ( SQL_table_prefix.equals( "" ) ) {
            General.showError("code bug trying to copy from special table that is not different from regular table.");
            return false;
        }
        /* By starting with mrfile the fastest stuff is done first so possible
         *errors are encountered fast and hopefully don't block the DB.
         */
        ArrayList temp_tables = new ArrayList();
        temp_tables.add( "mrfile" );
        temp_tables.add( "mrblock" );
        
        try {
            for (Iterator i=temp_tables.iterator();i.hasNext();) {
                String org_table  = (String) i.next();
                String temp_table = SQL_table_prefix + org_table;
                Statement stmt = conn.createStatement();            
                String q = 
                    "INSERT INTO " + org_table + General.eol + 
                    "SELECT * FROM " + temp_table;
                General.showDebug("Using query: [" + q + "]");
                int count = stmt.executeUpdate(q);
                General.showDebug("Updated rows: [" + count + "]");
                stmt.close();
                checkForWarning(conn.getWarnings());
            }
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.copyFromSpecialToRegularTables found Database access failed.\n" + e);
            return false;
        }
        return true;
    }
   
    
    /** Deletes all mrfiles from the database whose detail tag doesn't read: 
     *"classified".
     * @return true for success.
     */    
    public boolean deleteFilesNotClassified( ) {
       
        try {
            String mrfile_table = SQL_table_prefix + "mrfile";
            Statement stmt = conn.createStatement();            
            String q = 
                "DELETE \n" +
                "FROM " + mrfile_table + " f\n" +
                "WHERE f.DETAIL != '" + FILE_DETAIL_CLASSIFIED +"'";
            General.showDebug("Using query: [" + q + "]");
            int count = stmt.executeUpdate(q);
            General.showDebug("Deleted rows: [" + count + "]");
            stmt.close();
            checkForWarning(conn.getWarnings());
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.deleteFilesNotClassified found Database access failed.");
            General.showThrowable(e);
            return false;
        }
        return true;
    }
    
    /** Deletes all mrfiles from the database that are in DOCR or FRED
     *for a certain PDB id.
     * @return true for success.
     */    
    public boolean deleteFilesDOCRFRED( String pdb_id ) {
        try {
            String mrfile_table = SQL_table_prefix + "mrfile";
            Statement stmt = conn.createStatement();
            String q = 
                "DELETE \n" +
                "FROM " + mrfile_table + "\n" +
                "WHERE ( DETAIL = '" + FILE_DETAIL_CONVERTED +"' OR detail ='" + FILE_DETAIL_FILTERED + "' ) AND\n" +
                "pdb_id = '" + pdb_id + "'";
            General.showDebug("Using query: [" + q + "]");
            int count = stmt.executeUpdate(q);
            General.showDebug("Deleted rows: [" + count + "]");
            stmt.close();
            checkForWarning(conn.getWarnings());
        } catch (SQLException e) {
            General.showError("in SQL_Episode_II.deleteFilesDOCRFRED found Database access failed.");
            General.showThrowable(e);
            return false;
        }
        return true;
    }
    
    
    /** Deletes all mrfiles from the database whose detail tag doesn't read: 
     *"classified" and the pdb_entry_id is one of the ones in the list.
     * @return true for success.
     */    
    public boolean deleteFilesNotClassified( ArrayList pdb_entry_ids ) {
       
        final int MAX_IDS_PER_LINE = 10;
        try {
            String mrfile_table = SQL_table_prefix + "mrfile";
            Statement stmt = conn.createStatement();            
            String q = 
                "DELETE \n" +
                "FROM " + mrfile_table + General.eol +
                "WHERE DETAIL != '" + FILE_DETAIL_CLASSIFIED +"'\n";
            
            int index = 0;
            
            Iterator i=pdb_entry_ids.iterator();
            while ( i.hasNext() ) {
                String id = (String) i.next();
                if ( index == 0 ) {
                    q = q + "AND ( pdb_id='" + id + "' ";
                } else {
                    q = q + "OR pdb_id='" + id + "' ";
                }
                if ( (index % MAX_IDS_PER_LINE) == 0 ) {
                    q = q + General.eol;
                }
                index++;
            }
            
            if ( index > 0 ) {
                q = q + " )\n";
            }
            
            General.showDebug("Using query: [" + q + "]");
            int count = stmt.executeUpdate(q);
            General.showDebug("Deleted rows: [" + count + "]");
            stmt.close();
            checkForWarning(conn.getWarnings());
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.deleteOldConvertedFiles found Database access failed.\n" + e);
            return false;
        }
        return true;
    }

    /** Empties a series of tables in multiple SQL commands.
     *This method doesn't work on the dbfs. Make sure it does what you expect it
     *to do in this regard.
     * @return true for success.
     * @param do_standard_tables If true the action will be performed even if the prefix is the empty
     * string which would result in the emptying of the default tables. This is just a code check
     *to prevent accidental deleting info from the default tables.
     * @param tables Names of tables to empty before name prefix is added.
     */    
    public boolean emptyTables( ArrayList tables, boolean do_standard_tables ) {
       
        if ( SQL_table_prefix == "" && ( ! do_standard_tables ) ) {
            General.showError("SQL_table_prefix is empty string but do_standard_tables is false (in emptyTables).");
            return false;
        }

        try {
            for (Iterator i=tables.iterator();i.hasNext();) {
                String table = SQL_table_prefix + i.next();
                Statement stmt = conn.createStatement();            
                String q = "DELETE FROM " + table;
                General.showDebug("Using query: [" + q + "]");
                int count = stmt.executeUpdate(q);
                General.showDebug("Deleted rows: [" + count + "]");
                stmt.close();
                checkForWarning(conn.getWarnings());
            }
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.emptyTables found Database access failed.\n" + e);
            return false;
        }
        return true;
    }
    

    /** Delete an MRFiles given it's associated pdb_id and detail column.
     * This method uses auto committing.
     * @return Return value indicates success.
     */
    public boolean deleteMRFilesByIds(ArrayList mrfile_ids) {

        if ( mrfile_ids.size() < 0 ) {
            General.showError("number of mrfiles to delete < 0:"+ 
                mrfile_ids.size());
            return false;
        } else if ( mrfile_ids.size() == 0 ) {
            return true;
        }

        String mrfile_table = SQL_table_prefix + "mrfile";
        try 
        {
            Statement stmt = conn.createStatement();            
            String q = "DELETE FROM " + mrfile_table + " WHERE\n";
            for (Iterator i=mrfile_ids.iterator();i.hasNext();) {
                q = q + "mrfile_id=" + i.next();
                if ( i.hasNext()) {
                    q = q + " OR\n";
                } else {
                    q = q + General.eol;
                }            
            }
            General.showDebug("Using query: [" + q + "]");
            int count = stmt.executeUpdate(q);
            if ( count != mrfile_ids.size() ) {
                General.showError("number of mrfiles deletes is: " + count + " but: " + 
                    mrfile_ids.size() + " expected to be deleted.");
            } else {
                General.showOutput("The number of mrfiles deleted              : "
                    + count );
            }            
            stmt.close();
            checkForWarning(conn.getWarnings());
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.deleteMRFilesByIds found Database access failed.\n" + e);
            return false;
        }
        return true;
    }
    
    
    /** Delete an entry given it's associated pdb_ids and detail.
     * @return Return value indicates success.
     */
    public boolean deleteEntryByPDBIds(ArrayList pdb_ids) {

        if ( pdb_ids.size() < 0 ) {
            General.showError("in SQL_Episode_II.deleteEntryByPDBIds number of mrfiles to delete < 0:"+ 
                pdb_ids.size());
            return false;
        } else if ( pdb_ids.size() == 0 ) {
            return true;
        }
        
        try 
        {
            Statement stmt = conn.createStatement();            
            String q = "DELETE FROM entry WHERE\n (\n";

            for (Iterator i=pdb_ids.iterator();i.hasNext();) {
                q = q + "pdb_id='" + i.next() + "'";
                if ( i.hasNext()) {
                    q = q + " OR\n";
                } else {
                    q = q + "\n)\n";
                }            
            }
            
            General.showDebug("Query is: [" + q + "]");
            int count = stmt.executeUpdate(q);
            if ( count != pdb_ids.size() ) {
                General.showWarning("in SQL_Episode_II.deleteEntryByPDBIds entry updates: " + count + " but: " + 
                    pdb_ids.size() + " expected to be deleted.");
            } else {
                General.showOutput("The number of entries deleted              : " 
                    + count );
            }            
            stmt.close();
            checkForWarning(conn.getWarnings());
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.deleteMRFilesByPDBIdsByDetail found Database access failed.\n" + e);
            return false;
        }
        return true;
    }

    /** Delete an MRFiles given it's associated pdb_ids and detail.
     * @return Return value indicates success.
     */
    public boolean deleteMRFilesByPDBIdsByDetail(ArrayList pdb_ids, 
        String detail) {

        if ( pdb_ids.size() < 0 ) {
            General.showError("number of mrfiles to delete < 0:"+ 
                pdb_ids.size());
            return false;
        } else if ( pdb_ids.size() == 0 ) {
            return true;
        }
        String mrfile_table = SQL_table_prefix + "mrfile";
        
        try 
        {
            Statement stmt = conn.createStatement();            
            String q = "DELETE FROM " + mrfile_table + " WHERE\n";
            q = q + "(\n";
            for (Iterator i=pdb_ids.iterator();i.hasNext();) {
                q = q + "pdb_id='" + i.next() + "'";
                if ( i.hasNext()) {
                    q = q + " OR\n";
                } else {
                    q = q + General.eol;
                }            
            }
            q = q + ")\n";
            q = q + "AND detail='" + detail + "'\n";
            
            General.showDebug("Query is: [" + q + "]");
            int count = stmt.executeUpdate(q);
            if ( count != pdb_ids.size() ) {
                General.showError("mrfiles updates: " + count + "but: " + 
                    pdb_ids.size() + "expected to be deleted");
            } else {
                General.showOutput("The number of mrfiles deleted              : "
                    + count );
            }            
            stmt.close();
            checkForWarning(conn.getWarnings());
        } catch (SQLException e)
        {
            General.showError("in SQL_Episode_II.deleteMRFilesByPDBIdsByDetail found Database access failed.\n" + e);
            return false;
        }
        return true;
    }
    
    
    /** Given the pdb entry code return the first entry id that matches for the
     * pdb id. If there is no such pdb id then create a new entry with that pdb id and
     * a new entry id.
     *The method uses transaction management.
     * @param pdb_id The pdb entry code.
     * @return First entry_id for which the pdb id matches in the database. A null
     *value indicates an error.
     */    
    public DBEntry.Retval getEntryByPDBId( String pdb_id ) {
        DBEntry.Retval ret = new DBEntry.Retval();
        
        //String entry_table = SQL_table_prefix + "entry";
        String entry_table = "entry";
        
        try {
            // Disable auto commit so update can be rolled back
            conn.setAutoCommit(false);
            Statement stmt = conn.createStatement();            
            ResultSet rs = stmt.executeQuery(
                "SELECT entry_id, bmrb_id, pdb_id \n"+
                "FROM " + entry_table + General.eol +
                "WHERE pdb_id='" + pdb_id + "'" );

            if (rs.next()) 
            {
                //General.showOutput("Entry already existed for pdb id: ["+pdb_id+"]");
                // Null values can be checked with rs.wasNull()
                // Here we leave the value set to -1 indicating
                // null as defined in Wattos.Utils.General.NULL_FOR_INTS
                //
                ret.entry_id = rs.getInt(      "entry_id");
                ret.bmrb_id  = rs.getInt(      "bmrb_id");
                /* Has to follow the column on which to operate.
                if (rs.wasNull())
                    General.showOutput("BMRB id was null for this entry");
                 */
                ret.pdb_id   = rs.getString(   "pdb_id");
                //General.showOutput("Got " + ret.entry_id + " " + ret.bmrb_id + " " + ret.pdb_id);
            } else {
                General.showDebug("Entry did not exist for pdb id: ["+pdb_id+"]");
                // Get unique sequence id from db.
                ret.entry_id = getNextSequenceId( "entry" );
                if ( ret.entry_id == Wattos.Utils.General.NULL_FOR_INTS ) {
                    General.showError("in SQL_Episode_II.getEntryByPDBId found no next sequence id obtained");
                    conn.setAutoCommit(true);
                    return null;
                }
                String query = 
                    "INSERT INTO " + entry_table + " (entry_id, pdb_id) "+
                    "VALUES ( "+ ret.entry_id + ", '" + pdb_id + "')";                    
                General.showDebug("query is:\n" + query);
                
//                int count = stmt.executeUpdate( query );  
                stmt.executeUpdate( query );  
//                if ( count != 1 ) {
//                    General.showDebug("in SQL_Episode_II.getEntryByPDBId found insertion returned ["+count+
//                        "] insertions which should have been exactly one. " +
//                        "This code used to work but fails on my development machine under Mac OSX.");
////                    rs.close(); 
////                    stmt.close();		// All done with that result set
////                    rollbackTransaction();
////                    conn.setAutoCommit(true);
////                    return null;
//                }                                                        

                // Set the rest.
                ret.bmrb_id  = Wattos.Utils.General.NULL_FOR_INTS;
                ret.pdb_id   = pdb_id;                        
            }
            // Do these need to be executed before a return, or is it just 
            // nice to do so?
            rs.close(); 
            stmt.close();		// All done with that result set
            // Do the commit after having finished the read out of possible
            // result sets.
            conn.commit();
            conn.setAutoCommit(true);
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e) {
            General.showError("in SQL_Episode_II.getEntryByPDBId found Database access failed.");
            e.printStackTrace(System.err);
            General.showError( "getMessage              : " + e.getMessage());
            General.showError( "getErrorCode            : " + e.getErrorCode());
            General.showError( "getLocalizedMessage     : " + e.getLocalizedMessage());
            return null;
        }
        return(ret);
    }
    
    
    /** Load the picture to the DB. This class has to use Oracle specific classes
     * in order to get the BLOB to work. It is expected that other databases have
     * similar classes available so that minimal modifications are required to get
     * this method to work on other databases.
     *The method uses transaction management.
     *
     * @param entry_id The entry id.
     * @param filename The filename of the image file to be loaded. It will be loaded again from
     * file.
     * @param width The width(x) of the image as previously determined.
     * @param height The height(y) of the image as previously determined.
     * @param type Image type which can only be "gif" or "jpg" at this moment.
     * @return <CODE>true</CODE> if successful in all aspects.
     *  
    public boolean putPicture (int entry_id, String filename, 
                            int width, int height, String type, String detail) {

        String image_table = SQL_table_prefix + "image";         
        
        try {
            // Get next new id
            int image_id = getNextSequenceId( "image" );            
            if ( image_id == Wattos.Utils.General.NULL_FOR_INTS ) {
                General.showError("in SQL_Episode_II.putPicture found returning from getNextSequenceId");
                return false;
            }
            
            // Disable auto commit so update can be rolled back
            conn.setAutoCommit(false);
            
            /* Form a SQL statement for inserting a row into table.
               The LOB column value is initialized to empty in this step, and
               will be loaded in the steps below.           *
            PreparedStatement pstmt = conn.prepareStatement(
                "INSERT INTO " + image_table + General.eol + 
                "(image_id, entry_id, width, height, type, detail, image) VALUES"+
                "(?,?,?,?,?,?,empty_blob())"
            );
            
            pstmt.setInt(    1,     image_id);
            pstmt.setInt(    2,     entry_id);
            pstmt.setInt(    3,     width);
            pstmt.setInt(    4,     height);
            pstmt.setString( 5,     type);            
            pstmt.setString( 6,     detail);            
            pstmt.execute();
            pstmt.close();	// All done with that statement but not committed            

            // Retrieve the row just inserted, and lock it for insertion of the
            // LOB columns.
            Statement stmt = conn.createStatement();            
            ResultSet rs = stmt.executeQuery(
              "SELECT image FROM " + image_table + General.eol +
              "WHERE image_id = "+image_id+" FOR UPDATE");

            // Retrieve BLOB stream for image
            // columns, and load the sample files
            if (rs.next()) {
                // Get the BLOB locator and open output stream for the BLOB
                BLOB imageBLOB = ((OracleResultSet)rs).getBLOB("image");
                OutputStream imageBLOBOutputStream = imageBLOB.getBinaryOutputStream();

                // Open the file as a stream for insertion into the BLOB column
                File imageBLOBFile = new File(filename);
                InputStream imageBLOBFileStream = new FileInputStream(imageBLOBFile);

                // Buffer to hold chunks of data to being written to the BLOB.
                // In Oracle8.1.5 JDBC drivers a method getBufferSize() is available
                // in the BLOB class, that returns the optimal buffer size
                byte[] l_buffer = new byte[10 * 1024];

                // Read a chunk of data from the file input stream, and write the
                // chunk to the BLOB column output stream. Repeat till file has been
                // fully read.
                int l_nread = 0;   // Number of bytes read
                //General.showOutput("Loading image into DB.");
                while ((l_nread= imageBLOBFileStream.read(l_buffer)) != -1) // Read from file
                  imageBLOBOutputStream.write(l_buffer,0,l_nread); // Write to BLOB

                // Close both streams
                imageBLOBFileStream.close();
                imageBLOBOutputStream.close();

                //General.showOutput("Done Loading image file to DB.");
            } else {
                General.showError("in SQL_Episode_II.putPicture found Got no pointer for updating image.");
                // Rollback and reset auto commit parameter to default.
                rollbackTransaction();
                return false;
            }
            // Close Result Set and statement
            rs.close(); 
            stmt.close();
            // Only commit if all statements were successful...
            conn.commit();            
            conn.setAutoCommit(false);
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } 
        catch (SQLException ex) {
            General.showError("in SQL_Episode_II.putPicture found Database access failed.");
            ex.printStackTrace();
            rollbackTransaction();
            return false;
        }
        catch (Exception ex) { // Trap file i/o errors
            General.showError("in SQL_Episode_II.putPicture found File i/o errors.");
            ex.printStackTrace();
            rollbackTransaction();
            return false;
        }
        return true;        
    }
     */

    /** Load the DBMRBlock into the DB. 
     *If the meta data fails to load in then the file isn't written.
     *If the file doesn't get written then the meta data (in db) is
     *no longer consistent. The meta data should then be removed
     *by caller. Use the method: makeDBFSConsistent
     *
     *Creates a new dbfs_id, content if needed, and md5sum.
     *
     * @return <CODE>true</CODE> if successful in all aspects.
     * @throws SQLException 
     */    
    public boolean putMRBlockTransactionStyle ( DBMRBlock mrb ) 
        throws SQLException, IOException {
        
        // Get next new id
        mrb.mrblock_id = getNextSequenceId( "mrblock" );
        if ( mrb.mrblock_id == Wattos.Utils.General.NULL_FOR_INTS ) {
            General.showError("in SQL_Episode_II.putMRBlockTransactionStyle found returning from getNextSequenceId for mr block");
            return false;
        }

        // Get next new dbfs id
        mrb.dbfs_id = getNextSequenceId( "dbfs" );
        if ( mrb.dbfs_id == Wattos.Utils.General.NULL_FOR_INTS ) {
            General.showError("in SQL_Episode_II.putMRBlockTransactionStyle found returning from getNextSequenceId for dbfs");
            return false;
        }

        //General.showOutput("Dumping DBMRBlock into DB. Block id: " + mrb.mrblock_id + " dbfs_id: " + mrb.dbfs_id);
        // Create the actual text or binary and make sure the md5 sum is calculated on the fly.
        if ( mrb.content == null ) {
            General.showError("No content for mrb with id: " + mrb.mrblock_id);
            return false;
        }        
        mrb.md5Sum = PrimitiveArray.getMD5SumString( mrb.content );
        if ( mrb.md5Sum == null ) {
            General.showError("Failed to find md5 sum for mrb with id: " + mrb.mrblock_id);
            return false;
        }
        
        String mrblock_table = SQL_table_prefix + "mrblock"; 
        
        /* Form a SQL statement for inserting a row into table.
           The LOB column value is initialized to empty in this step, and
           will be loaded in the steps below.           */
        PreparedStatement pstmt = conn.prepareStatement(
            "INSERT INTO " + mrblock_table + General.eol + 
            "(mrblock_id, mrfile_id, position, "+                       //1-3
            " program, type, subtype, format, " +                       //4-7
            " text_type, byte_count, date_modified, " +                 //8-10
            " other_prop, " +                                           //11
            " dbfs_id, file_name, item_count, md5_sum ) VALUES"+        //12-15
            "(?,?,?,?,?," +
             "?,?,?,?,?," +
             "?,?,?,?,?)"
        );

        pstmt.setInt(       1,     mrb.mrblock_id);
        pstmt.setInt(       2,     mrb.mrfile_id);
        pstmt.setInt(       3,     mrb.position);
        pstmt.setString(    4,     mrb.type[0]);
        pstmt.setString(    5,     mrb.type[1]);
        pstmt.setString(    6,     mrb.type[2]);            
        pstmt.setString(    7,     mrb.type[3]);            
        pstmt.setString(    8,     mrb.text_type);            
        pstmt.setInt(       9,     mrb.content.length);            
        
        java.sql.Timestamp ts = new java.sql.Timestamp( mrb.date_modified.getTime() );
        //((OraclePreparedStatement)pstmt).setTimestamp(10,     ts );
        pstmt.setTimestamp(10,     ts );
        pstmt.setString(   11,     Strings.getProperties(mrb.other_prop));            
        pstmt.setInt(      12,     mrb.dbfs_id);
        pstmt.setString(   13,     mrb.fileName);
        if ( Defs.isNull(mrb.item_count) ) {
            pstmt.setNull(      14,    Types.INTEGER);
            //General.showOutput("Found NULL value for item count");
        } else {
            pstmt.setInt(       14,     mrb.item_count);
            //General.showOutput("Found non-NULL value for item count: " + mrb.item_count);
        }
        pstmt.setString(   15,     mrb.md5Sum);

        /* Alternatively */
        //((OraclePreparedStatement)pstmt).setDate( 10, date );
        // Alternative that didn't work yet.
        //pstmt.setString(   11,     formatWithSql92Date(mrb.date_modified));                    
        // Alternative that might even be faster: use SYSDATE function in pstmt
        // Not tested so far.

//        General.showOutput( "Prepared statement looks like: " + pstmt.toString());
        pstmt.execute();
        pstmt.close();	// All done with that statement but not committed            
         

        DBFSFile dbfsFile = new DBFSFile(mrb.dbfs_id);        
        // Check for existance which would be bad.
        if ( dbfsFile.getFile().exists() ) {
            General.showError("DBFS File already existed; that's serious: " + dbfsFile.getFile());
            return false;
        }
        try {
            if ( ! dbfsFile.createContainingDirIfNeeded()) {
                General.showError("Failed to create containing dir if needed for dbfs file: " + dbfsFile);
                return false;
            }
            //RandomAccessFile raf = new RandomAccessFile(dbfsFile.getFile(),"rw");
            FileOutputStream fos = new FileOutputStream( dbfsFile.getFile() );
            //GZIPOutputStream gzos = new GZIPOutputStream( fos ); // zipped again even if not zipped before.
            // Use the zip compression instead because it can be optimized for speed.
            ZipOutputStream gzos = new ZipOutputStream( fos ); 
            ZipEntry ze = new ZipEntry( dbfsFile.getFile().toString() );
            gzos.putNextEntry(ze);
            gzos.setLevel( Deflater.BEST_SPEED  );
            gzos.write( mrb.content );
            gzos.close();
            fos.close();
        } catch ( Throwable t ) {
            General.showThrowable(t);
            return false;
        }
        //General.showDebug("The file size        : " + dbfsFile.getFile().length());
        //General.showDebug("The mrb.content size : " + mrb.content.length );
         
        // Any warnings generated by the sql connection?
        checkForWarning(conn.getWarnings());
        return true;
    }


    /** Load the DBMRFile to the DB.
     * This method will call putMRBlockTransactionStyle for each block it contains.
     *
     * The method does use transaction management. MRBlocks will be inserted
     * one at a time. If any fail the user would have to manually delete those
     * that have been inserted.
     * @return <CODE>true</CODE> if successful in all aspects.
     * @param mrf The DBMRFile object to load into DB.
     */    
    public boolean putMRFile ( DBMRFile mrf ) {

        //General.showOutput("Dumping DBMRFile into DB");
        
        // Get an existing entry_id or a new one if none for the pdb_id existed.
        DBEntry.Retval dbe = getEntryByPDBId( mrf.pdb_id );
        if ( dbe == null ) {
            General.showError("in SQL_Episode_II.putMRFile found Failed to get or assign a entry_id for this DBMRFile");
            General.showError("given pdb id: " + mrf.pdb_id );
            return false;
        }

        String mrfile_table = SQL_table_prefix + "mrfile"; 
        // Did we succeed?
        boolean status = true;
        
        try {
            // Get next new id
            mrf.mrfile_id = getNextSequenceId( "mrfile" );
            if ( mrf.mrfile_id == Wattos.Utils.General.NULL_FOR_INTS ) {
                General.showError("in SQL_Episode_II.putMRFile found returning from getNextSequenceId");
                return false;
            }

            conn.setAutoCommit(false);
            /* Form an SQL statement for inserting a row into table.
               The LOB column value is initialized to empty in this step, and
               will be loaded in the steps below.           
             */
            PreparedStatement pstmt = conn.prepareStatement(
                "INSERT INTO " + mrfile_table + General.eol +
                "(mrfile_id, entry_id, detail, pdb_id, date_modified) VALUES"+
                "(?,?,?,?,?)" );
            pstmt.setInt(    1,     mrf.mrfile_id);
            pstmt.setInt(    2,     dbe.entry_id);
            pstmt.setString( 3,     mrf.detail);
            pstmt.setString( 4,     mrf.pdb_id);
            
            
            java.sql.Timestamp ts = new java.sql.Timestamp( mrf.date_modified.getTime() );
            // Specialize it so Oracle can use it. Obviously oracle specific.
            //((OraclePreparedStatement)pstmt).setTimestamp(5, ts );
            pstmt.setTimestamp(5, ts );
            /* if not interested beyond the day
            java.sql.Date date = new java.sql.Date( mrf.date_modified.getTime() );
            ((OraclePreparedStatement)pstmt).setDate( 5, date );
             */
            
            pstmt.execute();
            pstmt.close();	// All done with that statement but not committed            
                        
            // Commit only if all puts are successful
//            int position=0;
            for (Iterator i=mrf.blocks.iterator();i.hasNext();) {
                DBMRBlock mrb = (DBMRBlock) i.next();
                mrb.mrfile_id = mrf.mrfile_id;
                // The next function throws exceptions that lead to all
                // updates being rolled back.
                status = putMRBlockTransactionStyle( mrb );
                if ( ! status )
                    break;
            }
            
            if ( status ) {            
                //General.showOutput("Committing changes.");
                conn.commit();
                conn.setAutoCommit(true);
            } else {
                General.showError("in SQL_Episode_II.putMRFile found. Will rollback changes.");
                rollbackTransaction();
                General.showError("rollback changes completed.");
                General.showError("Files might still reside in the DBFS without being referenced.");
                General.showError("It's suggested to clean the DBFS by querying the database for any unused files.");
                status = false;
                if ( ! makeDBFSConsistent()) {
                    General.showError("Failed to make DBFS consistent by using this program. Please do by 'hand'.");                    
                }
                // status will remain false
            }
        }    
        catch (SQLException ex) {
            General.showError("in SQL_Episode_II.putMRFile found Database access failed.");
            ex.printStackTrace();
            rollbackTransaction();
            return false;
        }
        catch (IOException ex) {
            General.showError("in SQL_Episode_II.putMRFile found I/O error.");
            ex.printStackTrace();
            rollbackTransaction();
            return false;
        }
        //General.showDebug("Put " + mrf.blocks.size() + " DBMRBlocks into database for this file.");
        return status;        
    }

    /** Removes any DBFS file (interactively) not refered to by the DB and
     *mentions any missing DBFS file refered to by the DB suggesting to 
     *remove the row in which it is refered to.
     *Returns true only if there were no errors or all errors could be fixed.
     */
    public boolean makeDBFSConsistent()
    {   
        boolean status = true;
        
        IntArrayList dbfsFiles_in_db = new IntArrayList();
        IntArrayList dbfsFiles_in_fs = null;
        
        for (int i=0; i<DBFS_REFERING_TUPLES.length; i++ ) {
            String tableName = SQL_table_prefix + DBFS_REFERING_TUPLES[i][0];
            String colName   = DBFS_REFERING_TUPLES[i][1];
            General.showDebug( "Looking for zombie dbfs files in database table: " + 
                tableName + " and column: " + colName );

        
            String query =
                "SELECT " + colName + " AS dbfs_id\n"+
                "FROM " + tableName  + " ";
            General.showDebug("Complete selection statement: [\n"+query+"\n]");
                
            try {
                Statement stmt = conn.createStatement();        
                ResultSet rs = stmt.executeQuery( query );
                int rows_retrieved = 0;
                while ( rs.next() ) {
                    dbfsFiles_in_db.add( rs.getInt("dbfs_id") );                    
                    /* Has to follow the column on which to operate.*/
                    if ( rs.wasNull() ) {
                        status = false;       
                    }
                    rows_retrieved++;
                }
                //General.showOutput("Retrieved number of rows:"+rows_retrieved);

                rs.close(); 
                stmt.close();		// All done with that resultset
                // Any warnings generated by the sql connection?
                checkForWarning(conn.getWarnings());
            } catch (SQLException e) {
                General.showError("in SQL_Episode_II.makeDBFSConsistent found Database access failed " + e);
                status = false;
            }
            if ( ! status ) {
                General.showError("Database access failed. Giving up." );
                return false;                
            }
            
        } // loop over tables
        dbfsFiles_in_db.sort();
        General.showOutput("Retrieved number of files in db            : "+dbfsFiles_in_db.size());
        dbfsFiles_in_fs = DBFSFile.getFiles_in_fs(); // already sorted
        General.showOutput("Retrieved number of files in fs            : "+dbfsFiles_in_fs.size());

        IntArrayList dbfsFiles_in_db_not_in_fs = PrimitiveArray.difference( dbfsFiles_in_db, dbfsFiles_in_fs);
        if ( dbfsFiles_in_db_not_in_fs.size() != 0 ) {
            General.showError("Found number of files in db referenced but not present in fs: " + dbfsFiles_in_db_not_in_fs.size());
            int totalCountRemoved = 0;
            for (int i=0; i<DBFS_REFERING_TUPLES.length; i++ ) {
                String tableName = SQL_table_prefix + DBFS_REFERING_TUPLES[i][0];
                String colName   = DBFS_REFERING_TUPLES[i][1];
                General.showDebug( "Preparing to remove zombie dbfs file reference rows in database table: " + 
                    tableName + " and column: " + colName );
                boolean useBrackets = false;
                String query =
                    "DELETE FROM " + tableName  + General.eol +
                    "WHERE dbfs_id IN ( " + 
                    PrimitiveArray.toString( dbfsFiles_in_db_not_in_fs, useBrackets ) +
                    " ) ";
                General.showDebug("Complete deletion statement: [\n"+query+"\n]");
                String prompt = "Do you want to delete these mrblocks with this command?";
                boolean reply = Strings.getInputBoolean(prompt);
                if ( reply ) {
                    try {
                        Statement stmt = conn.createStatement();        
                        int count = stmt.executeUpdate( query );
                        General.showOutput("Removed number of rows from this table: "+count);
                        totalCountRemoved += count;
                        stmt.close();		// All done with that resultset
                        // Any warnings generated by the sql connection?
                        checkForWarning(conn.getWarnings());
                    } catch (SQLException e) {
                        General.showError("in SQL_Episode_II.makeDBFSConsistent found Database access failed " + e);
                        status = false;
                    }
                } else {
                    status = false;
                    General.showError("Failed to make db consistent.");
                }
                if ( ! status ) {
                    General.showError("Database access failed. Giving up." );
                    return false;                
                }

            } // end loop over tables
            if ( totalCountRemoved != dbfsFiles_in_db_not_in_fs.size() ) {
                General.showError("Expected to remove references in db: " + dbfsFiles_in_db_not_in_fs.size());
                General.showError("But removed references in db       : " + totalCountRemoved);
                General.showError("Will continue to try to remove other inconsistency but this one remains.");
                status = false;
            }
        }
//        General.showDebug("writing dbfsFiles_in_fs ");
//        General.showDebug("writing dbfsFiles_in_db ");
//        Strings.writeToFile(PrimitiveArray.toString(dbfsFiles_in_fs,false,true),"dbfsFiles_in_fs.txt");
//        Strings.writeToFile(PrimitiveArray.toString(dbfsFiles_in_db,false,true),"dbfsFiles_in_db.txt");
        IntArrayList dbfsFiles_in_fs_not_in_db = PrimitiveArray.difference( dbfsFiles_in_fs, dbfsFiles_in_db);
        if ( dbfsFiles_in_fs_not_in_db.size() != 0 ) {
            General.showError("Found number of files in fs but not referenced in db: " + dbfsFiles_in_fs_not_in_db.size());

            String prompt = "Should all these DBFS files be deleted from fs?\n" +
                PrimitiveArray.toString( dbfsFiles_in_fs_not_in_db ) + General.eol;            
            boolean doDelete = Strings.getInputBoolean(prompt);
            if ( doDelete ) {
                int[] elements = PrimitiveArray.getElements( dbfsFiles_in_fs_not_in_db );
                if ( ! DBFSFile.delete( elements )) {
                    General.showError("Failed to remove all dbfs files");
                    return false;
                }
            } else {
                General.showError("Leaving inconsistent dbfs files in fs. Clean up manually please.");
                return false;
            }
        }
        return status;
    }
    
    
    
    /** Saves entry from DB to given file given it's image id.
     * The method does NOT use transaction management (only queries).
     *
     * @param filename_base The filename without path and extension where the image will be saved.
     * @param image_id The id for the image to be retrieved.
     * @return Return value is the filename_extension (image type) or null in
     * case of failure.
     * 
    public String getPicture (String filename_base, int image_id) {

        String filename_extension = null; // To be returned
        General.showOutput("Getting image from DB");
        
        String image_table = SQL_table_prefix + "image"; 

        try {
            Statement stmt = conn.createStatement();        
            ResultSet rs = stmt.executeQuery(
              "SELECT image, type FROM " + image_table + General.eol+
              "WHERE IMAGE_ID = "+image_id);

            // Retrieve BLOB stream for image
            // columns, and load the sample files
            if (rs.next()) {
                filename_extension = ((OracleResultSet)rs).getString("type");
                // Get the BLOB locator and open output stream for the BLOB
                BLOB imageBLOB = ((OracleResultSet)rs).getBLOB("image");
                InputStream imageBLOBInputStream = imageBLOB.getBinaryStream();

                // Open the file as a stream for insertion into the BLOB column
                String filename = filename_base + "." + filename_extension;
                File imageBLOBFile = new File(filename);
                OutputStream imageBLOBFileStream = new FileOutputStream(imageBLOBFile);

                // Buffer to hold chunks of data to being written to the BLOB.
                // In Oracle8.1.5 JDBC drivers a method getBufferSize() is available
                // in the BLOB class, that returns the optimal buffer size
                byte[] l_buffer = new byte[10 * 1024];

                // Read a chunk of data from the file input stream, and write the
                // chunk to the BLOB column output stream. Repeat till file has been
                // fully read.
                int l_nread = 0;   // Number of bytes read
                while ((l_nread= imageBLOBInputStream.read(l_buffer)) != -1) // Read from file
                  imageBLOBFileStream.write(l_buffer,0,l_nread); // Write to BLOB

                // Close both streams
                imageBLOBFileStream.close();
                imageBLOBInputStream.close();

                General.showOutput("Done Loading image file from DB");
            } else {
                General.showWarning("No image with image_id: " + image_id);
            }

            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());

            // Close Result Set and statement
            rs.close(); 
            stmt.close();
        } 
        catch (SQLException ex) {
            General.showOutput("Database access failed");
            ex.printStackTrace();
        }
        catch (Exception ex) { // Trap file i/o errors
            General.showOutput("File I/O errors");
            ex.printStackTrace();
        }
        return ( filename_extension );
    } 
     */   
    
    
    /** Gets DBMRFile object from DB given it's id.
     * The method does NOT use transaction management (only queries).
     * The method does not do an explicit write to disk.
     * @param mrfile_id The DBMRFile id.
     * @return <CODE>true</CODE> if successful in all aspects.
     */    
    public boolean getMRFile (DBMRFile mrf, int mrfile_id) {
        mrf.mrfile_id = mrfile_id;
        return getMRFile(mrf);
    }

    /** Gets DBMRFile object from DB using it's id.
     * The method does NOT use transaction management (only queries).
     * The method does not do an explicit write to disk.
     * @param mrf
     * @return <CODE>true</CODE> if successful in all aspects.
     */    
    public boolean getMRFile (DBMRFile mrf) {

        boolean status = true;
//        int byte_count_check = 0;
//        String other_prop_str;
        IntArrayList blockList = new IntArrayList();
        
        //General.showOutput("Getting DBMRFile object from DB");

        // Initialize the object to nil.
        // Save before nilling
        int mrfile_id = mrf.mrfile_id;
        File file = mrf.file;
        mrf.init();
        mrf.mrfile_id = mrfile_id;
        mrf.file = file;

        String mrfile_table  = SQL_table_prefix + "mrfile"; 
        String mrblock_table = SQL_table_prefix + "mrblock"; 
        
        try {
            String query =
              "SELECT entry_id, detail, pdb_id, date_modified \n" +
              "FROM " +  mrfile_table + General.eol+
              "WHERE mrfile_id = " + mrfile_id;
            General.showDebug("Query is:\n" + query );

            Statement stmt = conn.createStatement();        
            ResultSet rs = stmt.executeQuery( query );
            
            if (rs.next()) 
            {
                mrf.entry_id        = rs.getInt(        "entry_id");
                mrf.detail          = rs.getString(     "detail");
                mrf.pdb_id          = rs.getString(     "pdb_id");
                mrf.date_modified   = rs.getTimestamp(  "date_modified");
                /* Has to follow the column on which to operate.*/
                if (rs.wasNull()) {
                    General.showWarning("BMRB id was null for this entry");
                    General.showOutput("It assigned a value:["+mrf.pdb_id + "] "+
                        "(reset to a null reference)");
                    mrf.pdb_id = null;
                }
            } else 
            {
                status = false;
                General.showError("in SQL_Episode_II.getMRFile found no DBMRFile object with mrfile_id:"+mrfile_id);
            }

            
            // No use in continuing if no mrfile is in the db.
            // Fetch mrblock id list
            if ( status ) {
                // needed?
                rs.close();
                stmt.close();
                stmt = conn.createStatement();
                query = 
                  "SELECT mrblock_id, position\n" +
                    "FROM " +  mrblock_table + General.eol+
                    "WHERE mrfile_id = "+mrfile_id+" "+
                    "ORDER BY position";
                General.showDebug("Full query is : \n" + query + General.eol);
                rs = stmt.executeQuery( query );
                
                // Retrieve blocks
                while ( rs.next() ) {
//                    blockList.add( ((OracleResultSet) rs).getInt("mrblock_id") );
                    blockList.add( rs.getInt("mrblock_id") );
                }
            }
            rs.close(); 
            stmt.close();		// All done with that resultset
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e) {
            General.showError("in SQL_Episode_II.getMRFile found Database access failed " + e);
            status = false;
        }

        // do the real fetch
        for (int i=0;i<blockList.size();i++) {
            DBMRBlock mrb = new DBMRBlock();
            mrb.mrblock_id = blockList.getQuick(i);
            if ( ! getMRBlock(mrb) ) {
                General.showError("Failed to get MRBlock from db with id: " + mrb.mrblock_id);
                return false;
            }
            mrf.blocks.add(mrb);
        }
            
        if ( mrf.blocks.size() >= 1 ) {
            General.showDebug("Done loading mrfile from DB");
        } else {
            General.showWarning("No mrblocks in mrfile with mrfile_id: " + mrfile_id);
            status = false;
        }
        return status;
    }
    

    /** Gets DBMRFile object from DB using it's id.
     * The method does NOT use transaction management (only queries).
     * @param mrb
     * @return <CODE>true</CODE> if successful in all aspects.
     */    
    public boolean getMRBlock (DBMRBlock mrb) {

        boolean status = true;
        int byte_count_check = -1;
        
        //General.showDebug("Getting DBMRBlock object from DB");
        //long time = System.currentTimeMillis();

        // Initialize the object to nil.
        // Save before nilling
        int mrblock_id=mrb.mrblock_id;
        mrb.init();

        String mrblock_table = SQL_table_prefix + "mrblock"; 
        String q = 
          "SELECT mrfile_id, position, program, type, subtype, " +               // 1-5
          "       format, text_type, byte_count, date_modified, other_prop, " +  // 6-10
          "       dbfs_id, file_name, item_count, md5_sum \n"+              // 11-14
          "FROM " + mrblock_table + " \n"+
          "WHERE mrblock_id = "+mrblock_id + General.eol;
        
        try {            
            Statement stmt = conn.createStatement();        
            ResultSet rs = stmt.executeQuery( q );

            if ( rs.next() ) {
                mrb.mrblock_id          = mrblock_id;
                /**
                mrb.mrfile_id           = ((OracleResultSet)rs).getInt(   "mrfile_id");
                mrb.position            = ((OracleResultSet)rs).getInt(   "position");
                mrb.type[0]             = ((OracleResultSet)rs).getString("program");
                mrb.type[1]             = ((OracleResultSet)rs).getString("type");
                mrb.type[2]             = ((OracleResultSet)rs).getString("subtype");
                mrb.type[3]             = ((OracleResultSet)rs).getString("format");
                mrb.text_type           = ((OracleResultSet)rs).getString("text_type");
                byte_count_check        = ((OracleResultSet)rs).getInt(   "byte_count");
                mrb.date_modified       = ((OracleResultSet)rs).getTimestamp(  "date_modified");
                String o_prop_str       = ((OracleResultSet)rs).getString("other_prop");
                mrb.dbfs_id             = ((OracleResultSet)rs).getInt(   "dbfs_id");
                mrb.fileNameExtension   = ((OracleResultSet)rs).getString("file_name");
                mrb.md5Sum              = ((OracleResultSet)rs).getString( "md5_sum");
                 */
                mrb.mrfile_id           = rs.getInt(   "mrfile_id");
                mrb.position            = rs.getInt(   "position");
                mrb.type[0]             = rs.getString("program");
                mrb.type[1]             = rs.getString("type");
                mrb.type[2]             = rs.getString("subtype");
                mrb.type[3]             = rs.getString("format");
                mrb.text_type           = rs.getString("text_type");
                byte_count_check        = rs.getInt(   "byte_count");
                mrb.date_modified       = rs.getTimestamp(  "date_modified");
                String o_prop_str       = rs.getString("other_prop");
                mrb.dbfs_id             = rs.getInt(   "dbfs_id");
                mrb.fileName            = rs.getString("file_name");
                mrb.item_count          = rs.getInt(   "item_count");
                mrb.md5Sum              = rs.getString( "md5_sum");
                
                mrb.other_prop  = Strings.setProperties( o_prop_str );
                
                if ( mrb.md5Sum == null ) {
                    General.showError("Failed to get md5 sum string representation.");
                    return false;
                }
                
                if ( mrb.md5Sum.length() != PrimitiveArray.MD5SumStringLength ) {
                    General.showError("Didn't get the right length for byte array for md5 sum.");
                    General.showError("Needed: " + PrimitiveArray.MD5SumStringLength + " But got: " + mrb.md5Sum.length() );
                    return false;
                }
                DBFSFile dbfsFile = new DBFSFile(mrb.dbfs_id);
                String readValuesHash = null;
                File f = dbfsFile.getFile();
                try {
                    //int fileSize = (int) dbfsFile.getFile().length();                    
                    /** Calculate digest on the fly as a filtering operation.
                    MessageDigest digester = null;
                    try {
                        digester = MessageDigest.getInstance("MD5");
                    } catch ( NoSuchAlgorithmException e ) {
                        General.showThrowable(e);
                        return false;
                    }
                     */
                    FileInputStream fis = new FileInputStream( f );
                    ZipInputStream gzis = new ZipInputStream( fis );
                    ZipEntry ze = gzis.getNextEntry();
                    if ( ze == null ) {
                        General.showError("Found no zip entry");
                        return false;
                    }
                    
                    //General.showDebug("Retrieving zipEntry  : " + ze.getName());
                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
                    int BUFFER_SIZE = 1024 * 10;
                    byte[] buffer = new byte[BUFFER_SIZE];
                    int in = gzis.read(buffer);        
                    
                    while (in != -1)        {            
                        baos.write(buffer,0,in);            
                        in = gzis.read(buffer);        
                    }  
                    gzis.closeEntry();
                    gzis.close();  // next statements probably redundant.      
                    fis.close();
                    mrb.content = baos.toByteArray();                    
                    //General.showDebug("Read number of unzipped bytes: " + mrb.content.length);
                    //readValuesHash = digester.digest();
                    //General.showDebug("Digest: " + Strings.toHex( readValuesHash ));                            
                } catch ( FileNotFoundException t ) {
                    General.showError( "File Not Found: " + f.toString() + ". Perhaps the block disappeared by DB update");
                    return false;
                } catch ( IOException t ) {
                    General.showThrowable(t);
                    return false;
                }
                readValuesHash = PrimitiveArray.getMD5SumString( mrb.content );
                if ( ! readValuesHash.equals( mrb.md5Sum ) ) {
                    // TODO enable this check with return false again when 
                    // archive is up to snuff.
                    General.showError("The 2 MD5 hashes don't match. Stored   : "+
                            mrb.md5Sum + " but retrieved: "+readValuesHash);
//                    return false;
                }
                //General.showDebug("Retrieved data has matching MD5 sum hash: " + mrb.md5Sum);
            } else {
                // Got no result.
                General.showDebug("in SQL_Episode_II.getMRBlock found: No mrblocks with mrblock_id: " + mrblock_id);
                status = false;
            }
            rs.close(); 
            stmt.close();		// All done with that resultset
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e) {
            General.showError("in SQL_Episode_II.getMRBlock found Database access failed " + e);
            status = false;
        }
        if ( ! status ) {
            General.showDebug("Failed to SQL_Episode_II.getMRBlock for query:\n" + q);            
            return false;            
        }
        int mrbContentLength = Defs.NULL_INT;
        if ( mrb.content != null ) {
            mrbContentLength = mrb.content.length;
        }
        if ( mrb.content.length != byte_count_check ) {
            General.showError("The stored byte_count doesn't match the content, stored byte_count : " + 
                    mrbContentLength+" and content byte_count: " + byte_count_check);
            status = false;
        }
        //time = System.currentTimeMillis() - time;
        //General.showDebug("Time for getMRBlock from DB(FS): " + time);
        return status;
    }
    

    /** Gets the associated PDB code for a block.
     * The method does NOT use transaction management (only queries).
     * @param mrb
     * @return <CODE>pdb code</CODE> if successful in all aspects and null if not.
     */    
    public String getPdbId (DBMRBlock mrb) {

        boolean status = true;
        String result = null;
        
        General.showDebug("Getting PDB id from DB");

        // Initialize the object to nil.
        // Save before nilling
        int mrblock_id=mrb.mrblock_id;
        
        String mrblock_table = SQL_table_prefix + "mrblock"; 
        String mrfile_table = SQL_table_prefix + "mrfile"; 

        try {
            String query =
                  "SELECT f.pdb_id AS pdb_id\n"+
                     "FROM " + mrfile_table  + " f, \n"+
                               mrblock_table + " b \n"+
                  "WHERE b.mrfile_id=f.mrfile_id AND\n"+
                  "      b.mrblock_id="+mrblock_id + General.eol;
            //General.showOutput("query: " + query);
            Statement stmt = conn.createStatement();        
            ResultSet rs = stmt.executeQuery(query);

            // Retrieve CLOB stream for text columns
            if ( rs.next() ) {
                result = rs.getString("pdb_id");
            } else {
                // Got no result.
                General.showError("in SQL_Episode_II.getPdbId found No pdb_id found for mrblock with mrblock_id: " + mrblock_id);
                status = false;
            }
            rs.close(); 
            stmt.close();		// All done with that resultset
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e) {
            General.showError("in SQL_Episode_II.getPdbId found Database access failed " + e);
            status = false;
        }

        if ( status )
            return(result);
        else
            return(null);
    }
    

    /** Get a set of MRFile objects from db.
     */

    public DbTable getMRFileSetTable ( HashMap options, String selection ) {
        
        General.showDebug("Getting FileSetTable from DB");

        int status = 0;
                        
        String mrblock_table = SQL_table_prefix + "mrblock"; 
        String mrfile_table = SQL_table_prefix  + "mrfile"; 
        String entry_table = "entry";
        //String entry_table = SQL_table_prefix   + "entry"; 

        String query = 
            "SELECT f.mrfile_id, e.pdb_id, e.bmrb_id, e.in_recoord, e.in_dress,\n"+
            "       f.detail AS stage\n"+
            "FROM " + mrfile_table  + " f, \n"+
                      mrblock_table + " b, \n"+
                      entry_table   + " e \n"+
            "WHERE e.entry_id=f.entry_id AND f.mrfile_id=b.mrfile_id AND\n"+
            "   " + STUB_SQL_STRING_TRUE + General.eol+
            "GROUP BY f.mrfile_id, e.pdb_id, e.bmrb_id, f.detail\n"+
            "ORDER BY e.pdb_id ASC, f.detail ASC, f.mrfile_id ASC";
                    
        // Can't use regular expressions for they contain unescaped special
        // characters.
        int stub_location = query.indexOf(STUB_SQL_STRING_TRUE);
        StringBuffer sb = new StringBuffer(query);
        sb.delete(stub_location, stub_location + STUB_SQL_STRING_TRUE.length());
        sb.insert(stub_location, selection);
        General.showDebug("Complete selection statement: [\n"+sb+"\n]");
        
        // New database table
        DbTable dbt = new DbTable();
        
        try {
            Statement stmt = conn.createStatement();        
            ResultSet rs = stmt.executeQuery( sb.toString() );
            
            // All data will be of type String except the last column which
            // will be of type int. Queries with only one column as a result
            // have a column that is of type int too.
            ResultSetMetaData rsmd = rs.getMetaData();
            int columnCount = rsmd.getColumnCount();
            for (int i=1;i<=columnCount;i++) {
                // Name of column
                dbt.labels.add( rsmd.getColumnLabel(i) );
                // Type of column in a db independent manner as defined by
                // java.sql.TYPES
                dbt.types.add( new Integer(rsmd.getColumnType(i)) );
                dbt.typenames.add( rsmd.getColumnTypeName(i) );
                dbt.values_by_col.add( new ArrayList() );
            }
            
            int rows_retrieved = 0;
            while ( rs.next() ) {
                for (int i=1;i<=columnCount;i++) {
                    ArrayList al = (ArrayList) dbt.values_by_col.get(i-1);
                    // Some columns contain nummeric values. All but
                    // the mrfile_id can be null
                    if ( i == 1 || i == 3 ) {
                        int v = rs.getInt(i);
                        // Has to follow the getter!
                        if ( rs.wasNull() ) { // actually can't be null so waisting time...
                            al.add( null );
                        } else {
                            al.add( new Integer( v ));
                        }
                    } else if ( i == 4 || i == 5 ) {
                        al.add( new Boolean( rs.getBoolean(i) ));
                    } else {
                        al.add( rs.getString(i) );
                    }
                    
                    /* Has to follow the column on which to operate.*/
                    if (rs.wasNull()) {
                        if ( i == 1 ) {
                            General.showError("in SQL_Episode_II.getMRFileSetTable found retrieved a null value");
                            status++;
                        } else {
                            // A null pointer can always be used to indicate
                            // absence of any type of object even for the wrapper
                            // classes like Integer.
                            al.set( al.size()-1, null );
                        }
                        
                    }
                }
                rows_retrieved++;
            }
            General.showDebug("Retrieved number of rows:"+rows_retrieved);
            
            rs.close(); 
            stmt.close();		// All done with that resultset
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e) {
            General.showError("in SQL_Episode_II.getMRFileSetTable Database access failed " + e);
            status++;
        }
            
        if ( status==0 ) {
            return( dbt );
        } else {                
            return(null);
        }
    }
    
    
    /** Get a set of MRBlock objects from db.
     */

    public ArrayList getMRBlockIds ( HashMap options, String selection ) {
        
        General.showDebug("Getting Block Ids from DB");

        int status = 0;
        ArrayList al = new ArrayList();
        
        String mrblock_table    = SQL_table_prefix + "mrblock"; 
        String mrfile_table     = SQL_table_prefix + "mrfile"; 
        //String entry_table      = SQL_table_prefix + "entry"; 
        String entry_table = "entry";
        

        String query =
            "SELECT b.mrblock_id AS mrblock_id\n"+
            "FROM " + mrfile_table  + " f, \n"+
                      mrblock_table + " b, \n"+
                      entry_table   + " e \n"+
            "WHERE e.entry_id=f.entry_id AND f.mrfile_id=b.mrfile_id AND\n"+
            "   " + STUB_SQL_STRING_TRUE + General.eol+
            "ORDER BY b.mrblock_id ASC, b.position ASC";
        // Can't use regular expressions for they contain unescaped special
        // characters.
        int stub_location = query.indexOf(STUB_SQL_STRING_TRUE);
        StringBuffer sb = new StringBuffer(query);
        sb.delete(stub_location, stub_location + STUB_SQL_STRING_TRUE.length());
        sb.insert(stub_location, selection);
        General.showDebug("Complete selection statement: [\n"+sb+"\n]");
                
        try {
            Statement stmt = conn.createStatement();        
            ResultSet rs = stmt.executeQuery( sb.toString() );
            
            int rows_retrieved = 0;

            while ( rs.next() ) {
                al.add( new Integer( rs.getInt("mrblock_id") ));                    
                /* Has to follow the column on which to operate.*/
                if ( rs.wasNull() )
                    status++;                        
                rows_retrieved++;
            }
            General.showDebug("Retrieved number of rows:"+rows_retrieved);
            
            rs.close(); 
            stmt.close();		// All done with that resultset
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e) {
            General.showError("in SQL_Episode_II.getMRBlockIds found Database access failed " + e);
            status++;
        }
            
        if ( status==0 ) {
            return al;
        }
        return null;
    }
    

    
    /** Get a set of MRBlock objects from db.
     */

    public DbTable getMRBlockSetTable ( HashMap options, String selection ) {
        
        General.showDebug("Getting BlockSetTable from DB");

        //long time = System.currentTimeMillis();
        int status = 0;
        String mrblock_table = SQL_table_prefix + "mrblock"; 
        String mrfile_table  = SQL_table_prefix + "mrfile"; 
        String entry_table = "entry";        
        //String entry_table   = SQL_table_prefix + "entry"; 
                        
        String query =
            "SELECT b.mrblock_id, e.pdb_id, e.bmrb_id,\n" +                                   // 1-3
            "       e.in_recoord, e.in_dress,\n" +                                            // 4-5
            "       f.detail AS stage,\n"+                                                    // 6
            "       b.position, b.program, b.type,\n"+                                        // 7-9            
            "       b.subtype, b.format,\n" +                                                 //10-11
            "       b.item_count, b.other_prop\n"+                                            //12-13
            "FROM " + mrfile_table  + " f, \n"+
                      mrblock_table + " b, \n"+
                      entry_table   + " e \n"+
            "WHERE e.entry_id=f.entry_id AND f.mrfile_id=b.mrfile_id AND\n"+
            "   " + STUB_SQL_STRING_TRUE + General.eol+
            "ORDER BY e.pdb_id ASC, f.detail ASC, f.mrfile_id ASC, b.position ASC";
        // Can't use regular expressions for they contain unescaped special
        // characters.
        int stub_location = query.indexOf(STUB_SQL_STRING_TRUE);
        StringBuffer sb = new StringBuffer(query);
        sb.delete(stub_location, stub_location + STUB_SQL_STRING_TRUE.length());
        sb.insert(stub_location, selection);
        General.showDebug("Complete selection statement: [\n"+sb+"\n]");
        
        // New database table
        DbTable dbt = new DbTable();
        
        try {
            Statement stmt = conn.createStatement();        
            ResultSet rs = stmt.executeQuery( sb.toString() );
            
            // All data will be of type String except the last column which
            // will be of type int. Queries with only one column as a result
            // have a column that is of type int too.
            ResultSetMetaData rsmd = rs.getMetaData();
            int columnCount = rsmd.getColumnCount();
            for (int i=1;i<=columnCount;i++) {
                // Name of column
                dbt.labels.add( rsmd.getColumnLabel(i) );
                // Type of column in a db independent manner as defined by
                // java.sql.TYPES
                dbt.types.add( new Integer(rsmd.getColumnType(i)) );
                dbt.typenames.add( rsmd.getColumnTypeName(i) );
                dbt.values_by_col.add( new ArrayList() );
            }
            
            int rows_retrieved = 0;
            while ( rs.next() ) {
                for (int i=1;i<=columnCount;i++) {
                    ArrayList al = (ArrayList) dbt.values_by_col.get(i-1);
                    if ( i == 1 || i == 3 || i == 7 || i == 12  ) {
                        int v = rs.getInt(i);
                        // Has to follow the getter!
                        if ( rs.wasNull() ) {
                            al.add( null );
                        } else {
                            al.add( new Integer( v ));
                        }
                    /** Change the textual representation of the other properties
                     */
                    } else if ( i == 4 || i == 5 ) {
                        al.add( new Boolean( rs.getBoolean(i) ));
                    } else if ( i == 13 ) {
                        String other_prop_str = rs.getString(i);
                        Properties other_prop = Strings.setProperties(other_prop_str);
                        al.add( Strings.getPropertiesNoBrackets(other_prop ));  
                    } else {
                        al.add( rs.getString(i) );
                    }
                    
                    /* Has to follow the column on which to operate.*/
                    if (rs.wasNull()) {
                        // Just check the mrfile_id and mrblock_id
                        if ( i == 1  ) {
                            General.showError("in SQL_Episode_II.getMRBlockSetTable retrieved a null value for b.mrblock_id");
                            status++;
                        } else {
                            // A null pointer can always be used to indicate
                            // absence of any type of object even for the wrapper
                            // classes like Integer.
                            al.set( al.size()-1, null );
                        }                        
                    }
                }
                rows_retrieved++;
            }
            General.showDebug("Retrieved number of rows:"+rows_retrieved);
            
            rs.close(); 
            stmt.close();		// All done with that resultset
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e) {
            General.showError("in SQL_Episode_II.getMRBlockSetTable found Database access failed " + e);
            status++;
        }
            
        if ( status!=0 ) {
            return null;
        }
        
        //time = System.currentTimeMillis() - time;
        //General.showDebug("Time for getMRBlockSetTable: " + time);

        return dbt;        
    }
    
    /** Gets DBMRFile object from DB using it's id.
     * The method does NOT use transaction management (only queries).
     * @return List of four DbTable objects with the counts or null if
     * the lookup failed. If four empty DbTable objects are returned that is 
     * valid.

     The most complicated string constructed will be for file count. See
     *SQL code within function.
     *Where 1=1 is a stub for more selection code.
    */

    public ArrayList getMRItemCounts ( HashMap options, String selection ) {

        General.showDebug("Getting MRItemCounts object from DB");

        //String STUB_SQL_STRING_TRUE = "1=1";
        ArrayList results = new ArrayList();
        int status = 0;

        String mrblock_table = SQL_table_prefix + "mrblock"; 
        String mrfile_table  = SQL_table_prefix + "mrfile"; 
        String entry_table = "entry";
        //String entry_table   = SQL_table_prefix + "entry"; 
        
        String[][] query = 
{ {
      
// *************************        BLOCKS         ***********************
// Get the grid data for total/program (I)
"SELECT COUNT(*) AS count\n"+
"FROM " + mrfile_table  + " f, \n"+
          mrblock_table + " b, \n"+
          entry_table   + " e \n"+
"WHERE f.mrfile_id=b.mrfile_id AND\n"+
"      f.entry_id=e.entry_id AND\n" +
"    " + STUB_SQL_STRING_TRUE + General.eol,


// Get the grid data for total/program (II)
"SELECT program, COUNT(*) AS count\n"+
"FROM " + mrfile_table  + " f, \n"+
          mrblock_table + " b, \n"+
          entry_table   + " e \n"+
"WHERE f.mrfile_id=b.mrfile_id AND\n"+
"      f.entry_id=e.entry_id AND\n" +
"    " + STUB_SQL_STRING_TRUE + General.eol+
"GROUP BY program",


// Get the grid data for total/type (III)
"SELECT type, subtype, format, COUNT(*) AS count\n"+
"FROM " + mrfile_table  + " f, \n"+
          mrblock_table + " b, \n"+
          entry_table   + " e \n"+
"WHERE f.mrfile_id=b.mrfile_id AND\n"+
"      f.entry_id=e.entry_id AND\n" +
"    " + STUB_SQL_STRING_TRUE + General.eol+
"GROUP BY type, subtype, format",


// Get the grid data for total/program/type (IV)
"SELECT program, type, subtype, format, COUNT(*) AS count\n"+
"FROM " + mrfile_table  + " f, \n"+
          mrblock_table + " b, \n"+
          entry_table   + " e \n"+
"WHERE f.mrfile_id=b.mrfile_id AND\n"+
"      f.entry_id=e.entry_id AND\n" +
"    " + STUB_SQL_STRING_TRUE + General.eol+
"GROUP BY program, type, subtype, format"},{


      /** OLD SCHOOL 
// *************************        FILES         ***********************
// Get the grid data for total/total (I)
"SELECT count(*) AS count\n"+
"FROM (\n"+
"        SELECT b.mrfile_id\n"+
         "FROM " + mrfile_table  + " f, \n"+
                   mrblock_table + " b \n"+
//                   entry_table   + " e \n"+
"        WHERE f.mrfile_id=b.mrfile_id AND\n"+
"            " + STUB_SQL_STRING_TRUE + General.eol+
"        GROUP BY b.mrfile_id\n"+
"     ) t\n"+
"",


// Get the grid data for total/program (II)
"SELECT t.program, count(*) AS count\n"+
"FROM (\n"+
"	SELECT b.program, b.mrfile_id\n"+
         "FROM " + mrfile_table  + " f, \n"+
                   mrblock_table + " b \n"+
//                   entry_table   + " e \n"+
"	WHERE f.mrfile_id=b.mrfile_id AND\n"+
"            " + STUB_SQL_STRING_TRUE + General.eol+
"	GROUP BY b.program, b.mrfile_id\n"+
"	) t\n"+
"GROUP BY t.program",


// Get the grid data for total/program (III)
"SELECT t.type, t.subtype, t.format, count(*) AS count\n"+
"FROM (\n"+
"	SELECT b.type, b.subtype, b.format, b.mrfile_id\n"+
         "FROM " + mrfile_table  + " f, \n"+
                   mrblock_table + " b \n"+
//                   entry_table   + " e \n"+
"	WHERE f.mrfile_id=b.mrfile_id AND\n"+
"            " + STUB_SQL_STRING_TRUE + General.eol+
"	GROUP BY b.type, b.subtype, b.format, b.mrfile_id\n"+
"	) t\n"+
"GROUP BY t.type, t.subtype, t.format",


// Get the grid data for total/program/type (IV)
"SELECT t.program, t.type, t.subtype, t.format, count(*) AS count\n"+
"FROM (\n"+
"	SELECT b.program, b.type, b.subtype, b.format, b.mrfile_id\n"+
         "FROM " + mrfile_table  + " f, \n"+
                   mrblock_table + " b \n"+
//                   entry_table   + " e \n"+
"	WHERE f.mrfile_id=b.mrfile_id AND\n"+
"            " + STUB_SQL_STRING_TRUE + General.eol+
"	GROUP BY b.program, b.type, b.subtype, b.format, b.mrfile_id\n"+
"	) t\n"+
"GROUP BY t.program, t.type, t.subtype, t.format"}};
       */
    
    
// *************************        FILES         ***********************
// Get the grid data for total/total (I)
"SELECT count(distinct(f.mrfile_id))\n"+ // perhaps even faster than a group by?
"FROM " + mrfile_table  + " f, \n"+
          mrblock_table + " b, \n"+
          entry_table   + " e \n"+
"WHERE f.mrfile_id=b.mrfile_id AND\n"+
"      f.entry_id=e.entry_id AND\n" +
"            " + STUB_SQL_STRING_TRUE + General.eol,

// Get the grid data for total/program (II)
"SELECT b.program, count(distinct(b.mrfile_id))\n"+
"FROM " + mrfile_table  + " f,\n"+
          mrblock_table + " b, \n"+
          entry_table   + " e \n"+
"WHERE f.mrfile_id=b.mrfile_id AND\n"+
"      f.entry_id=e.entry_id AND\n" +
"            " + STUB_SQL_STRING_TRUE + General.eol+
"GROUP BY b.program\n",

// Get the grid data for total/program (III)
"SELECT b.type, b.subtype, b.format, count(distinct(b.mrfile_id))\n"+
"FROM " + mrfile_table  + " f, \n"+
          mrblock_table + " b, \n"+
          entry_table   + " e \n"+
"WHERE f.mrfile_id=b.mrfile_id AND\n"+
"      f.entry_id=e.entry_id AND\n" +
"            " + STUB_SQL_STRING_TRUE + General.eol+
"GROUP BY b.type, b.subtype, b.format\n",


// Get the grid data for total/program/type (IV)
"SELECT b.program, b.type, b.subtype, b.format, count(distinct(b.mrfile_id))\n"+
"FROM " + mrfile_table  + " f, \n"+
          mrblock_table + " b, \n"+
          entry_table   + " e \n"+
"WHERE f.mrfile_id=b.mrfile_id AND\n"+
"      f.entry_id=e.entry_id AND\n" +
"            " + STUB_SQL_STRING_TRUE + General.eol+
"GROUP BY b.program, b.type, b.subtype, b.format\n"
}};
        
                           
        //boolean show_blocks         = ((Boolean)    options.get("show_blocks")).booleanValue();
        boolean show_blocks         = true;

        for (int total_id=0;total_id<4;total_id++) {
            
            // Construct the query from predefined piece and replace
            // the stub code by the extra limitations if any.
            // If show_blocks is true get the selection statements in the
            // first dimension of the query defined above.
            String q = query[show_blocks ? 0 : 1][total_id];
            StringBuffer sb = new StringBuffer(q);            
            int stub_location = q.indexOf(STUB_SQL_STRING_TRUE);
            sb.delete(stub_location, stub_location + STUB_SQL_STRING_TRUE.length());
            sb.insert(stub_location, selection);
            General.showDebug("Complete selection statement: [\n"+sb+"\n]");
            //long time = System.currentTimeMillis();
            
            // New database table
            DbTable dbt = new DbTable();
            
            try {
                Statement stmt = conn.createStatement();        
                ResultSet rs = stmt.executeQuery( sb.toString() );

                // All data will be of type String except the last column which
                // will be of type int. Queries with only one column as a result
                // have a column that is of type int too.
                ResultSetMetaData rsmd = rs.getMetaData();
                int columnCount = rsmd.getColumnCount();
                for (int i=1;i<=columnCount;i++) {
                    // Name of column
                    dbt.labels.add( rsmd.getColumnLabel(i) );
                    // Type of column in a db independent manner as defined by
                    // java.sql.TYPES
                    dbt.types.add( new Integer(rsmd.getColumnType(i)) );
                    dbt.typenames.add( rsmd.getColumnTypeName(i) );
                    dbt.values_by_col.add( new ArrayList() );
                }
                
                int rows_retrieved = 0;
                while ( rs.next() ) 
                {
                    for (int i=1;i<=columnCount;i++) {
                        ArrayList al = (ArrayList) dbt.values_by_col.get(i-1);
                        if ( i == columnCount ) {
                            al.add( new Integer( rs.getInt(i) ));
                        } else {
                            al.add( rs.getString(i) );
                        }
                        /* Has to follow the column on which to operate.*/
                        if (rs.wasNull()) {
                            General.showError("in SQL_Episode_II.getMRItemCounts found: Retrieved a null value");
                            status++;
                        }
                    }
                    rows_retrieved++;
                } 
                General.showDebug("Retrieved number of rows:"+rows_retrieved);
                
                rs.close(); 
                stmt.close();		// All done with that resultset
                // Any warnings generated by the sql connection?
                checkForWarning(conn.getWarnings());
            } catch (SQLException e) {
                General.showError("in SQL_Episode_II.getMRItemCounts found: Database access failed " + e);
                status++;
                break;
            }
            //time = System.currentTimeMillis() - time;
            //General.showDebug("Time for getting element "+results.size()+" of overall Results: " + time);
            results.add(dbt);
        }
        if ( status==0 ) {
            return( results );
        } else {                
            return(null);
        }
    }

    /** Gets a single BMRB id if the query results contain a single BMRB id
     *and return a zero if there are more or less than 1 entries.
     *Return -1 on error.
     *Where 1=1 is a stub for more selection code.
    */
    public int getSingleBMRBId( HashMap options, String selection ) {

        General.showDebug("Getting single BMRB id from DB");

        int result = -1;

        //if ( true ) return 4020;
        String mrblock_table = SQL_table_prefix + "mrblock"; 
        String mrfile_table  = SQL_table_prefix + "mrfile"; 
        String entry_table = "entry";
        
        String query = 
            "SELECT DISTINCT e.bmrb_id AS bmrb_id\n"+
            "FROM " + mrfile_table  + " f, \n"+
                      mrblock_table + " b, \n"+
                      entry_table   + " e \n"+
            "WHERE f.mrfile_id=b.mrfile_id AND\n"+
            "      f.entry_id=e.entry_id AND\n" +
            "    " + STUB_SQL_STRING_TRUE + "\n"+
            "GROUP BY e.bmrb_id\n" +
            "LIMIT 3\n"; // first can be a zero, second is real, third is too much.
                           
        query = query.replaceFirst(STUB_SQL_STRING_TRUE,selection);

        General.showDebug("Query is:\n" + query);
        try {
            Statement stmt = conn.createStatement();        
            ResultSet rs = stmt.executeQuery( query );

            ResultSetMetaData rsmd = rs.getMetaData();
            int columnCount = rsmd.getColumnCount();
            if ( columnCount != 1 ) {
                General.showError("Failed to get 1 column expected, got: " + columnCount);
                return -1;
            }
            int rows_retrieved = 0;
            while ( rs.next() ) {
               if ( rows_retrieved > 0 ) {
                   return 0;
               }
               result = rs.getInt(1);
                /* Has to follow the column on which to operate.*/
                if (rs.wasNull()) {
//                    General.showDebug("in SQL_Episode_II.getSingleBMRBId found: Retrieved a null value");
                    continue; // ignore possible initial null value.
                }
                rows_retrieved++;
            }
            General.showDebug("Retrieved number of rows with non-null values:"+rows_retrieved);
            if ( rows_retrieved == 0 ) {
                return 0;
            }
            rs.close(); 
            stmt.close();		// All done with that resultset
            // Any warnings generated by the sql connection?
            checkForWarning(conn.getWarnings());
        } catch (SQLException e) {
            General.showError("in SQL_Episode_II.getSingleBMRBId found: Database access failed " + e);
            return -1;
        }
        return result;
    }


    /** Tries to reopen the database connection for cases where the database was
     *closed during the servlets' lifetime.
    */
    public boolean reconnect( Globals g ) {
        // Try to close connection if it is still open.
        if ( conn != null ) {
            closeConnection();
        }
        
        // Reopen database connection
        General.showDebug("Trying to reconnect to DB");
        init( g );

        // Testing for a good connection is only done by an actual sql statement
        //if ( sql_epiII.conn != null ) { // Doesn't suffice
        if ( testConnection() ) {
            General.showDebug("Reconnected to DB");
            return true;
        }
            
        return false;
    }
    
    /** Self test; tests the method(s): getNextSequenceId and many others.
     * @param args Ignored.
     */
    public static void main (String[] args) {
        //General.verbosity = General.verbosityOutput;
        General.verbosity = General.verbosityDebug;
        // Usually needed for all tests
        Globals globals = new Globals();
        globals.showMap();

        // Open Episode_II database connection
        SQL_Episode_II sql_epiII = new SQL_Episode_II( globals );

        if ( sql_epiII == null ) {
            General.doCodeBugExit("Failed to connect to db");
        }
        
       if ( false ) {
            General.showOutput("Starting test of method: getNextSequenceId" );            
            int id = sql_epiII.getNextSequenceId( "dbfs" );
            General.showOutput("Got id: "+id );            
       }
       if ( false ) {
            General.showOutput("Starting test of method: getEntryByPDBId" );            
            DBEntry.Retval ret = sql_epiII.getEntryByPDBId( args[0] );
            if ( ret == null ) {
                General.showError("Failed to create new entry in DB");
                System.exit(0);
            }
       }
       if ( false ) {
            General.showOutput("Starting test of method: getMRItemCounts" );            
            ArrayList al_empty = new ArrayList(); 
            ArrayList al_pdb_id = new ArrayList();
            ArrayList al_block_detail = new ArrayList();
            //al_pdb_id.add("1brv");
            //al_pdb_id.add("1ci8");
            //al_block_detail.add("test");
            //al_block_detail.add("STAR");
            General.showOutput("al_pdb_id:       " + al_pdb_id );            
            General.showOutput("al_block_detail: " + al_block_detail );            
            HashMap options = new HashMap();
            options.put("pdb_ids", al_pdb_id);
            //options.put("bmrb_ids", al_empty);            
            options.put("block_details", al_block_detail);
            options.put("file_details", al_empty);
            //options.put("show_blocks", Boolean.valueOf(true));
            options.put("show_csv", Boolean.valueOf(false));
            // Selection is now done mostly from method in servlet.
            ArrayList ret = null;
            ret = sql_epiII.getMRItemCounts( options, "1=1" );
            //ret = sql_epiII.getMRItemCounts( options, "1=1" );
            if ( ret == null ) {
                General.showError("");
                System.exit(0);
            }
            /**
            General.showOutput("Table 1:" );            
            General.showOutput(( (DbTable) ret.get(0)).toString());
            General.showOutput("Table 2:" );            
            General.showOutput(( (DbTable) ret.get(1)).toString());
            General.showOutput("Table 3:" );            
            General.showOutput(( (DbTable) ret.get(2)).toString());
            General.showOutput("Table 4:" );            
            General.showOutput(( (DbTable) ret.get(3)).toString(true,true,true));
             */
        } 
       if ( false ) {
            General.showOutput("Starting test of method: getMRBlock" );
            DBMRBlock mrb = new DBMRBlock();
            mrb.mrblock_id = 1008;
            General.showOutput("Returned:"+sql_epiII.getMRBlock( mrb ) );            
            General.showOutput("mrb.content.size:"+ mrb.content.length);
       }        
       if ( false ) {
            General.showOutput("Starting test of method: getMRBlockids" );
            ArrayList al = sql_epiII.getMRBlockIds(new HashMap(), "e.entry_id=99");
            General.showOutput("Returned:"+ al );            
       }        
       if ( false ) {
           DBMRBlock mrb = new DBMRBlock();
           mrb.mrblock_id = 212982;
           General.showOutput("Returned:"+ sql_epiII.getPdbId(mrb) );            
       }        
        if ( false ) {
            General.showOutput("Testing connection:" );
            General.showOutput("Result: " + sql_epiII.reconnect(globals) );
        }
        if ( false ) {
            General.showOutput("Got entry by PDB id" );
            General.showOutput("Got entry: " + sql_epiII.getEntryByPDBId( "yyyy" ) );
        }
        if ( false ) {
            ArrayList al = sql_epiII.getPDBIdFromMRFileByDetailNewerThanDays(FILE_DETAIL_CLASSIFIED, 999);
            General.showOutput("Got annotated entries from DB:" + al);
        }
        if ( false ) {
            ArrayList temp_tables = new ArrayList();
            temp_tables.add( "mrfile" );
            temp_tables.add( "mrblock" );
            sql_epiII.SQL_table_prefix = "temp_";
            boolean status = sql_epiII.emptyTables( temp_tables, false );
            General.showOutput("emptyTables returned: " + status );     
        }
        if ( false ) {
            ArrayList temp_tables = new ArrayList();
            //temp_tables.add( "108d" );
            //temp_tables.add( "149d" );
            boolean status = sql_epiII.deleteFilesNotClassified( temp_tables );
            General.showOutput("deleteFilesNotClassified returned: " + status );     
        }
        if ( false ) {
            sql_epiII.SQL_table_prefix = "temp_";
            boolean status = sql_epiII.copyFromSpecialToRegularTables();
            General.showOutput("copyFromTempToRegularTables returned: " + status );     
        }

       if ( false ) {
            General.showOutput("Starting test of method: deleteEntryByPDBIds" );            
            ArrayList al_pdb_id = new ArrayList();
            al_pdb_id.add("1brv");
            General.showOutput("al_pdb_id:       " + al_pdb_id );            

            boolean ret = sql_epiII.deleteEntryByPDBIds( al_pdb_id );
            General.showOutput("returned: " + ret);
        } 
        General.showOutput("Done all selected tests!" );            
    }    
}
