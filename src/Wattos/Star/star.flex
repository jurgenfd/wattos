/*
 * This software is copyright (c) 2006 Board of Regents, University of
 * Wisconsin. All Rights Reserved.
 * 
 * $Id$
 *
 */
//***************************************************************************
// Scanner flex specification
//***************************************************************************
/* Lex Definitions for a STAR File */

package Wattos.Star;
import Wattos.Utils.*;

/**
 * STAR Lexer with some error checking.
 *
 * <STRONG>NOTES</STRONG>:<UL>
 *  <LI>this scanner does not close input file on EOF</LI>
 *  <LI>the scanner does not generate fake "end-of" tokens for
 *      end of data block, end of global block, end of loop
 *      (if closing "stop_" is omitted)</LI>
 *  <LI>this scanner generates "keyword in value" warnings (in C++
 *      version they are generated by the parser)</LI>
 * </UL>
 */

%%

%class STARLexer
%public
%line
%column
%unicode
%type Types
%x YYSINGLE YYDOUBLE YYSEMI YYSEMIEND

%init{
    buf = new StringBuilder();
%init}

%{
    private static final boolean DEBUG = false;
    
    public static final int ERROR = 0;
            /** Parser warning. */
    public static final int WARNING = 1;
            /** Start of global block. */
    public static final int GLOBALSTART = 2;
            /** End of global block. */
    public static final int GLOBALEND = 3;
            /** Start of data block. */
    public static final int DATASTART = 4;
            /** End of data block. */
    public static final int DATAEND = 5;
            /** Start of saveframe. */
    public static final int SAVESTART = 6;
            /** End of saveframe. */
    public static final int SAVEEND = 7;
            /** Start of loop. */
    public static final int LOOPSTART = 8;
            /** End of loop. */
    public static final int STOP = 9;   
            /** Tag. */
    public static final int TAGNAME = 10;
            /** Value enclosed in single quotes. */
    public static final int DVNSINGLE = 11;
            /** Value enclosed in double quotes. */
    public static final int DVNDOUBLE = 12;
            /** Value enclosed in semicolons. */
    public static final int DVNSEMICOLON = 13;
            /** Framecode value. */
    public static final int DVNFRAMECODE = 14;
            /** Bareword value. */
    public static final int DVNNON = 15;
            /** Comment. */
    public static final int COMMENT = 16;
            /** End of input. */
    public static final int EOF = 17;    
    /** tokens */
    public enum Types {
        /** Parser error. */
        ERROR,
        /** Parser warning. */
        WARNING,
        /** Start of global block. */
        GLOBALSTART,
        /** End of global block. */
        GLOBALEND,
        /** Start of data block. */
        DATASTART,
        /** End of data block. */
        DATAEND,
        /** Start of saveframe. */
        SAVESTART,
        /** End of saveframe. */
        SAVEEND,
        /** Start of loop. */
        LOOPSTART,
        /** End of loop. */
        STOP,
        /** Tag.  */
        TAGNAME,
        /** Value enclosed in single quotes. */
        DVNSINGLE,
        /** Value enclosed in double quotes. */
        DVNDOUBLE,
        /** Value enclosed in semicolons. */
        DVNSEMICOLON,
        /** Framecode value. */
        DVNFRAMECODE,
        /** Bareword value. */
        DVNNON,
        /** Comment. */
        COMMENT,
        /** End of input. */
        EOF;
    }
    /* buffer for quoted values */
    private StringBuilder buf;
    /** Returns line number (counting from 1).
     * Returns <CODE>yyline + 1</CODE>
     * @return line number
     */
    public int getLine() {
        return yyline + 1;
    }
    /** Returns column number.
     * @return column number
     */
    public int getColumn() {
        return yycolumn;
    }
    /** Returns text of the last token.
     * <P>
     * Use this method instead of <CODE>yytext()</CODE> to retrieve tokens.
     *<P>
     * Because quoted values (DVNSINGLE, DVNDOUBLE, DVNSEMICOLON) are parsed
     * differently from non-quoted ones (DVNNON and DVNFRAMECODE), their
     * text is stored in a separate buffer.
     * <P>
     * For other token types returns <CODE>yytext()</CODE>.
     */
    public String getText() {
        if( buf.length() < 1 ) return yytext();
    return buf.toString();
    }
    /** Pushes number of characters back into input stream.
     * @param num number of characters to push back
     */
    public void pushBack( int num ) {
        yypushback( num );
    }
    /** Marks input stream.
     * @param num read-ahead limit
     */
     /*
    public void mark( int num ) throws java.io.IOException {
    yy_reader.mark( num );
    }
    */
    /** Rewinds input stream to last mark. */
    /*
    public void rewind() throws java.io.IOException {
    yy_reader.reset();
    }
    */
//******************************************************************************
%}

WS=[ \t\b\012]
NON_WS=[^ \t\b\012\r]
NL=(\r|\n|\r\n)
WS_NL = ({WS}|{NL})
NON_NL = [^\r\n]

GLOBALSTART         = ([gG][lL][oO][bB][aA][lL]_)
DATASTART           = ([dD][aA][tT][aA]_)
SAVEEND             = ([sS][aA][vV][eE]_)
LOOPSTART           = ([lL][oO][oO][pP]_)
STOP                = ([sS][tT][oO][pP]_)
/*
   NMR-STAR 3.0/PDBX tagname
   TAGNAME              _[_[:alnum:]]+\.[][_[:alnum:]%-]+
*/
/* 
   NMR-STAR 2.1 tagname
   TAGNAME             = (_[_[:letter:][:digit:]+[\]\[_[:letter:][:digit:]%-]+)
*/
TAGNAME             = (_[_[:letter:][:digit:]]+[._\[\][:letter:][:digit:]%-]+)
//SINGLESTART         = {WS}+\'
//DOUBLESTART         = {WS}+\"

/*
   PDBX definition for code (sf name) is
   [_,.;:"&<>()/\{}'`~!@#$%A-Za-z0-9*|+-]+
*/
FRAMECODE           = \$[_,.;:\"&<>()/\{}'`~!@#$%A-Za-z0-9*|+-]+
COMMENT             = #

%%
<YYINITIAL> {
    <<EOF>> {
        buf.setLength( 0 );
        return Types.EOF;
    }
    {GLOBALSTART}{WS}* {
        buf.setLength( 0 );
        return Types.GLOBALSTART;
    }
    {DATASTART}{NON_WS}+ {
        buf.setLength( 0 );
        buf.append( yytext().substring( 5 ) );
        return Types.DATASTART;
    }
    {SAVEEND}{NON_WS}+ {
        buf.setLength( 0 );
        buf.append( yytext().substring( 5 ) );
        return Types.SAVESTART;
    }
    {SAVEEND}{WS}* {
        buf.setLength( 0 );
        return Types.SAVEEND;
    }
    {LOOPSTART}{WS_NL}* {
        buf.setLength( 0 );
        return Types.LOOPSTART;
    }
    {STOP}{WS}* {
        buf.setLength( 0 );
        return Types.STOP;
    }
    {COMMENT}.* {
        buf.setLength( 0 );
        return Types.COMMENT;
    }
    {TAGNAME} {
        buf.setLength( 0 );
        buf.append( yytext() );
        return Types.TAGNAME;
    }
    {FRAMECODE} {
        buf.setLength( 0 );
        buf.append( yytext().substring( 1 ) );
        return Types.DVNFRAMECODE;
    }
//    {SINGLESTART} {
    ({NL}|{WS})+\' {
if( DEBUG ) System.err.printf( "Matched |%s| in {SINGLESTART}\n", yytext() );
        buf.setLength( 0 );
        yybegin( YYSINGLE );
    }
//    {DOUBLESTART} {
    ({WS}|{NL})+\" {
if( DEBUG ) System.err.printf( "Matched |%s| in {DOUBLESTART}\n", yytext() );
        buf.setLength( 0 );
        yybegin( YYDOUBLE );
    }
    ^;.* {
//System.err.printf( "Matched %s in ^{SEMI}\n", yytext() );
        buf.setLength( 0 );
        buf.append( yytext().substring( 1 ) );
        yybegin( YYSEMI );
    }
    {NON_WS}+ {
if( DEBUG ) System.err.printf( "Matched |%s| in {NON_WS}+\n", yytext() );
        buf.setLength( 0 );
        buf.append( yytext() );
        return Types.DVNNON;
    }
    {WS_NL}+ {}
}

<YYSINGLE, YYDOUBLE> {
    . {
//System.err.printf( "Matched %s in {YYSINGLE|DOUBLE}, cont.\n", yytext() );
        buf.append( yytext() );
    }
}

<YYSINGLE>'/{WS_NL}+ {
//System.err.printf( "Matched %s in {YYSINGLE}, exit\n", yytext() );
    yybegin( YYINITIAL );
    return Types.DVNSINGLE;
}

<YYDOUBLE>\"/{WS_NL}+ {
//System.err.printf( "Matched %s in {YYDOUBLE}, exit\n", yytext() );
    yybegin( YYINITIAL );
    return Types.DVNDOUBLE;
}

<YYSEMI> {
    {NL} {
//System.err.printf( "In YYSEMI, matched |%s|, begin SEMIEND\n", yytext() );
    yybegin( YYSEMIEND );
    }
    {NON_NL}+ {
//System.err.printf( "In YYSEMI, matched |%s|\n", yytext() );
        buf.append( yytext() );
    }
}

<YYSEMIEND> {
    ;/{WS_NL} {
//System.err.printf( "In YYSEMIEND, matched |%s|, exit\n", yytext() );
        yybegin( YYINITIAL );
        return Types.DVNSEMICOLON;
    }
    {NL} {
        buf.append( "\n" );
    }
    [^;] {
//System.err.printf( "In YYSEMIEND, matched |%s|, drop back\n", yytext() );
        buf.append( "\n" );
        buf.append( yytext() );
        yybegin( YYSEMI );
    }
}

<YYINITIAL,YYSINGLE,YYDOUBLE,YYSEMI,YYSEMIEND>.|\n {
//System.err.printf( "In ERROR, matched |%s|\n", yytext() );
    buf.setLength( 0 );
    buf.append( "Unknown token: ``" );
    buf.append( yytext() );
    buf.append( "''" );
    return Types.ERROR;
}